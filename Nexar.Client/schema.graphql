schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

scalar Map

scalar Any

type Query {
  "Fetches an object given its ID."
  node("ID of the object." id: ID!): Node
  "Lookup nodes by a list of IDs."
  nodes("The list of node IDs." ids: [ID!]!): [Node]!
  "The project latest ECAD, MCAD or ESD revision."
  desProjectCollaborationLatestRevision("The identifier for a specific project." projectId: ID! "The collaboration domain." domain: DesCollaborationDomain!): DesCollaborationRevision
  "The project ECAD, MCAD or ESD revisions returned by pages."
  desProjectCollaborationRevisions("The identifier for a specific project." projectId: ID! domain: DesCollaborationDomain! "Returns the first N elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last N elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String): DesCollaborationRevisionConnection
  "*PROTOTYPE, SUBJECT TO CHANGE*"
  desProjectCollaborationSimulationRevisions(projectId: ID! domainName: String! "Returns the first N elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last N elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String): DesCollaborationSimulationRevisionConnection
  "*PROTOTYPE, SUBJECT TO CHANGE*"
  desProjectCollaborationSimulationLatestRevision(projectId: ID! domainName: String! projectTypeName: String!): DesCollaborationSimulationRevision
  "Search for comment threads associated with a project."
  desCommentThreads("The identifier for a project (This is the project field named \"id\")." projectId: ID!): [DesCommentThread!]!
  "Search for a specific comment thread associated with a project."
  desCommentThread("The identifier for a project (This is the project field named \"id\")." projectId: ID! "The reference identifier for a comment thread." threadId: String!): DesCommentThread
  desDesignItemById(id: ID!): DesDesignItem @deprecated(reason: "Will be removed in the future.")
  "Gets the library by workspace URL."
  desLibrary(workspaceUrl: String): DesLibrary!
  "Search a specific component by its unique identifier."
  desComponentById("The identifier for a component." id: ID!): DesComponent
  "Searches multiple components by their unique identifiers."
  desComponentsByIds("The identifiers for components." ids: [ID!]!): [DesUnionPayload!]!
  "Searches details of a revision by its unique identifier."
  desRevisionDetailsById("The node identifier for specific revision details." id: ID!): DesRevisionDetails @deprecated(reason: "Use `desRevisionDetailsByRevisionId` instead.")
  "Searches details of a revision by its reference identifier."
  desRevisionDetailsByRevisionId("The workspace in which the revision exists." workspaceUrl: String! "The reference identifier for a specific revision." revisionId: String!): DesRevisionDetails
  "Searches for a specific template for a component by its unique identifier."
  desComponentTemplateById("The node identifier for a component template." id: ID!): DesComponentTemplate
  "Searches for a specific folder by its unique identifier."
  desFolderById("The node identifier for a folder." id: ID!): DesFolder @deprecated(reason: "Use `DesFolderByFolderId` instead.")
  "Searches for a specific folder by its reference identifier."
  desFolderByFolderId(workspaceUrl: String! "The folder reference identifier." folderId: String!): DesFolder
  "Searches for a specific footprint by its unique identifier."
  desFootprintById("The node identifier for a footprint." id: ID!): DesFootprint
  "Searches for a specific symbol by its unique identifier."
  desSymbolById("The node identifier for a symbol." id: ID!): DesSymbol
  "The list of project tasks."
  desProjectTasks("The identifier for a specific project." projectId: ID! "Returns the first N elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last N elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String): DesTaskConnection
  "The list of workspace tasks."
  desWorkspaceTasks("The URL of the workspace to get tasks from." workspaceUrl: String "Returns the first N elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last N elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String): DesTaskConnection
  desManufacturePackages: [DesManufacturePackage!]!
  "Gets the manufacture package by its unique identifier."
  desManufacturePackageById("The node identifier for manufacture package." id: ID!): DesManufacturePackage @deprecated(reason: "Will be removed in the future.")
  "Search projects within a workspace with results in paged groups."
  desProjects("The web address of a workspace." workspaceUrl: String "Extra arguments." args: DesProjectsInput "Requirements block filter." requirementsBlockFilter: DesProjectsRequirementsBlockFilterInput "Returns the first N elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last N elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String where: DesProjectFilterInput): DesProjectConnection
  "Searches a project by its identifier."
  desProjectById("The project identifier." id: ID!): DesProject
  "Searches projects by their identifiers."
  desProjectsByIds("An array of project identifiers." ids: [ID!]!): [DesProject]!
  "Searches a release by its identifier."
  desReleaseById("The release identifier." id: ID!): DesRelease
  "Searches a project variant by its node identifier."
  desWipVariantById("The project variant node identifier." id: ID!): DesWipVariant @deprecated(reason: "Use `desWipVariantByVariantName` instead.")
  "Searches a project WIP variant by its name."
  desWipVariantByVariantName("The project identifier." projectId: ID! variantName: String!): DesWipVariant
  "Searches a release variant by its node identifier."
  desReleaseVariantById("The release variant node identifier." id: ID!): DesReleaseVariant
  "Gets the project identifier from its internal identifier."
  desProjectIdFromAfsId("The web address of a workspace." workspaceUrl: String "AFS internal identifier." afsId: String! "True for shared projects." isSharedProject: Boolean): DesProjectIdPayload!
  desBomById(id: ID!): DesBom @deprecated(reason: "Use `desWipVariantById` or `desReleaseVariantById` in order to access BOM.")
  "Find a specific reuse block by its unique identifier."
  desReuseBlockById("The node identifier for a reuse block." id: ID!): DesReuseBlock
  "Find specific reuse blocks by their unique identifiers."
  desReuseBlocksByIds("Node identifiers for the reuse blocks." ids: [ID!]!): [DesReuseBlock]!
  "Find a specific reuse block revision by its unique identifier."
  desReuseBlockRevisionById("The node identifier for a reuse block revision." id: ID!): DesReuseBlockRevision
  "Find specific reuse block revisions by their unique identifiers."
  desReuseBlockRevisionsByIds("Node identifiers for the reuse block revisions." ids: [ID!]!): [DesReuseBlockRevision]!
  "Gets the specified workspace team."
  desTeam(workspaceUrl: String): DesTeam!
  "Gets the specified workspace users by IDs."
  desUsers(workspaceUrl: String ids: [String!]!): [DesUser]!
  "Gets the authorized user."
  desUserByAuth: DesUser!
  "Gets a user by the specified global ID."
  desUserByGlobalId(id: String!): DesUser
  "Search for workspaces associated with this account."
  desWorkspaceInfos: [DesWorkspaceInfo!]!
  "Search a specific workspace by its unique identifier."
  desWorkspaceById("The node identifier for a workspace." id: ID!): DesWorkspace
  "Get a list of workspace locations."
  desWorkspaceLocations: [DesWorkspaceLocation!]!
  "Gets the specified settings."
  desSettings(workspaceUrl: String names: [String!]!): [String]!
  "Gets life cycle definitions."
  desLifeCycleDefinitions(workspaceUrl: String): [DesLifeCycleDefinition!]!
  "Gets a life cycle definition based on the id provided."
  desLifeCycleDefinitionById(id: ID!): DesLifeCycleDefinition
  "Gets the first allowed life cycle by the content kind."
  desLifeCycleDefinitionByContentTypeKind(workspaceUrl: String kind: DesContentTypeKind!): DesLifeCycleDefinition!
  "Gets revision naming schemes."
  desRevisionNamingSchemes(workspaceUrl: String): [DesRevisionNamingScheme!]!
  "Gets a revision naming scheme based on the ID provided."
  desRevisionNamingSchemeById(id: ID!): DesRevisionNamingScheme
  "Gets the first allowed naming scheme by the content kind."
  desRevisionNamingSchemeByContentTypeKind(workspaceUrl: String kind: DesContentTypeKind!): DesRevisionNamingScheme!
  "Gets the workspace configuration."
  desWorkspaceConfiguration(workspaceUrl: String): DesWorkspaceConfiguration!
  "Searches for a project template by its identifier."
  desProjectTemplateById("The project template node identifier." id: ID!): DesProjectTemplate
  "Searches for a project template revision by its identifier."
  desProjectTemplateRevisionById("The project template revision identifier." id: ID!): DesProjectTemplateRevision
  "Gets the creation job for a manufacture package by its unique identifier."
  desManufacturePackageCreationJob("The node identifier for a manufacture package creation job." id: ID!): DesManufacturePackageCreationJob
  "Gets the specified project export job."
  desProjectExportJob(projectExportJobId: String!): DesProjectExportJob!
  desSharedWithMe: DesSharedWithMe!
  supOctopartIdFromCiivaId(workspaceUrl: String ciivaId: String!): String @deprecated(reason: "Use `supPartIdFromCiivaId`.")
  "Nexar infrastructure, subject to change."
  supPartIdFromCiivaId(ciivaId: String!): String
  "Nexar infrastructure, subject to change."
  supPartIdsFromCiivaIds(ciivaIds: [String!]!): [String]!
  "Nexar infrastructure, subject to change."
  supCiivaIdFromPartId(partId: String!): String
  "Nexar infrastructure, subject to change."
  supCiivaIdsFromPartIds(partIds: [String!]!): [String]!
  "Nexar supply part data for internal use only."
  supPartExtrasByPartId(partId: String!): SupPartExtras
  "Nexar supply part data for internal use only."
  supPartExtrasByPartIds(partIds: [String!]!): [SupUnionPayload!]!
  "Search a specific workspace by its URL."
  desWorkspaceByUrl(workspaceUrl: String!): DesWorkspace
  desWorkspaces(where: DesWorkspaceFilterInput): [DesWorkspace!]! @deprecated(reason: "Use `desWorkspaceInfos`.")
  "Get all attributes"
  supAttributes: [SupAttribute!]!
  "Get manufacturer companies"
  supManufacturers("list of company IDs.  Omit to fetch all manufacturers." ids: [String!] "list of URL slugs for \/manufacturers paths" slugs: [String!] "Return only manufacturers that have a minimum number of active parts." minNumberOfActiveParts: Int): [SupCompany!]!
  "Get seller companies (distributors)"
  supSellers("list of company IDs.  Omit to fetch all sellers." ids: [String!] "Include only companies that support custom pricing." customPricingOnly: Boolean! = false "list of URL slugs for \/distributors paths" slugs: [String!]): [SupCompany!]!
  "Get categories"
  supCategories("list of category IDs. Omit to fetch all categories. Where id can be either an Octopart internal id or an Altium Global Resource ID (GRID)." ids: [String!] "list of SEO page paths for categories to include." paths: [String!] "Root of categories to include, defaults to ElectronicParts." root: SupCategoryRoot! = ElectronicParts): [SupCategory!]!
  "Get a single category by id. Where id can be either an Octopart internal id or an Altium Global Resource ID (GRID)."
  supCategoryById(id: ID!): SupCategory
  "Get a list of categories by ids. Where id can be either an Octopart internal id or an Altium Global Resource ID (GRID)."
  supCategoriesByIds(ids: [ID!]!): [SupCategory]!
  "Get parts by ID."
  supParts("list of part IDs. APIv3 UIDs are also supported." ids: [String!]! "user's country" country: String! = "US" "user's currency" currency: String! = "USD" "fetch latest pricing and stock data from distributor API. Company.isDistributorApi indicates if a distributor supports this feature." distributorApi: Boolean "how long to wait for distributor API to respond as a duration string (e.g. `3s` or `500ms`) up to a max 10s" distributorApiTimeout: String! = "3s" "if needed, pass along credentials for API integrations" customPricingCredentials: [SupApiCredentials!]): [SupPart]!
  "Get part offers by reference."
  supPartOffers(country: String! currency: String! references: [SupOfferReference!]! "fetch latest pricing and stock data from distributor API." distributorApi: Boolean "how long to wait for distributor API to respond as a duration string (e.g. `3s` or `500ms`)" distributorApiTimeout: String! = "3s" "if needed, pass along credentials for API integrations" customPricingCredentials: [SupApiCredentials!] priceBreaks: [Int!]): [SupPartOffer]!
  "Attempt to complete a partial query string.  Used for autosuggest \/ typeahead text inputs."
  supSuggest("partial query string" q: String! "categoryId to scope suggestions to" categoryId: String "only return part number suggestions" partNumbersOnly: Boolean): [SupSuggestion!]!
  "Search parts, including filters, pagination, aggregation, sorting"
  supSearch("the query to search" q: String "user's country" country: String! = "US" "user's currency" currency: String! = "USD" "offset in the result set" start: Int "page size of results" limit: Int "field to sort by.  See [sort values](https:\/\/octopart.com\/api\/v4\/values#sort)" sort: String "direction of sort: `asc` or `desc`" sortDir: SupSortDirection "filter to remove parts with no stocking distributors" inStockOnly: Boolean "filter to only include parts with a datasheet" hasDatasheetOnly: Boolean "a key: value map of filters. See [filter values](https:\/\/octopart.com\/api\/v4\/values#attributes)" filters: Map "fetch latest pricing and stock data from distributor API. Company.isDistributorApi indicates if a distributor supports this feature." distributorApi: Boolean "how long to wait for distributor API to respond as a duration string (e.g. `3s` or `500ms`)" distributorApiTimeout: String! = "3s" "if needed, pass along credentials for API integrations" customPricingCredentials: [SupApiCredentials!] "Specifying a ranking method." rankingMethod: SupSearchRankingMethod! = DEFAULT): SupPartResultSet!
  "Search parts by mpn only, including filters, pagination, aggregation, sorting"
  supSearchMpn("the query to search on mpn" q: String "user's country" country: String! = "US" "user's currency" currency: String! = "USD" "offset in the result set" start: Int "page size of results" limit: Int "field to sort by.  See [sort values](https:\/\/octopart.com\/api\/v4\/values#sort)" sort: String "direction of sort: `asc` or `desc`" sortDir: SupSortDirection "filter to remove parts with no stocking distributors" inStockOnly: Boolean "filter to only include parts with a datasheet" hasDatasheetOnly: Boolean "a key: value map of filters. See [filter values](https:\/\/octopart.com\/api\/v4\/values#attributes)" filters: Map "fetch latest pricing and stock data from distributor API. Company.isDistributorApi indicates if a distributor supports this feature." distributorApi: Boolean "how long to wait for distributor API to respond as a duration string (e.g. `3s` or `500ms`)" distributorApiTimeout: String! = "3s" "if needed, pass along credentials for API integrations" customPricingCredentials: [SupApiCredentials!] "Specifying a ranking method." rankingMethod: SupSearchRankingMethod! = DEFAULT): SupPartResultSet!
  "Suggest alternate queries when no results are found."
  supSearchCorrection(q: String!): [SupSearchCorrection!]!
  "Suggest an alternate `q` when no results are found. This treats the query as an MPN search so will return suggestions based on MPNs."
  supSpellingCorrection("query string to correct" q: String!): [SupSpellingCorrection!]!
  "Match multiple manufacturer + mpn pairs at once.  Useful for when you have a list of parts, as with a BOM (Bill of Materials)"
  supMultiMatch("list of inputs to attempt to match" queries: [SupPartMatchQuery!]! "options when matching such as applying filters or only including authorized or in-stock parts" options: SupPartMatchOptions "user's country" country: String! = "US" "user's currency" currency: String! = "USD" "fetch latest pricing and stock data from distributor API. Company.isDistributorApi indicates if a distributor supports this feature." distributorApi: Boolean "how long to wait for distributor API to respond as a duration string (e.g. `3s` or `500ms`)" distributorApiTimeout: String! = "3s" "if needed, pass along credentials for API integrations" customPricingCredentials: [SupApiCredentials!] "Specifying a ranking method." rankingMethod: SupSearchRankingMethod! = DEFAULT): [SupPartMatch!]!
  "Search a specific evaluation kit by its unique identifier."
  supEvalKitById(id: ID!): SupEvalKit
  "Search a specific evaluation kit by its unique identifier."
  supEvalKitsByIds(ids: [ID!]!): [SupEvalKit]!
  "List a evaluation kits."
  supEvalKits(q: String start: Int! = 0 limit: Int! = 10): [SupEvalKit]!
  "Search for part families and groups.\nThere is a limit on the number of parts allowed for each group. If you want the complete set of parts for a group\nmake a follow up request to `supPartGroupByName` or `supPartGroupById`."
  supPartFamilySearch("The query text for the descriptive search of the part groups." q: String! "Part group filters to be applied to this search." filters: SupPartFamilyFilterInput "Start offset of the results in the result set." start: Int = 0 "Page size of the results in the result set." limit: Int = 10): SupPartFamilyResultSet!
  "Search for part and group them by Part Group if applicable."
  supPartFamilyPartSearch("The query text for descriptive search." q: String "The query text for MPN matching search.\nOverride q when this input is given." mpn: String "Filter to remove parts with no stocking distributors." inStockOnly: Boolean "Filter to only include parts with a datasheet." hasDatasheetOnly: Boolean "Spec Filters to be applied." filters: Map): SupPartFamilyPartResultSet!
  "Get a specific part group by its unique identifier (GRID)."
  supPartGroupById(id: ID!): SupPartGroup!
  "Get a specific part group by its unique name."
  supPartGroupByName(name: String!): SupPartGroup!
  "Get a set of part groups by their unique identifiers (GRIDs).\nIf an ID is not found it will be returned as null, ensuring a one to one mapping of input ids to output."
  supPartGroupsByIds(ids: [ID!]!): [SupPartGroup]!
  "Get a part group by the ID of the part."
  supPartGroupByPartId(partId: ID!): SupPartGroup!
  "Get the set of filterable parameters for a part group within the given category."
  supPartFamilyParameters(categoryId: ID!): [SupPartFamilyParameter!]!
  "Search a specific reference design by its unique identifier."
  supRefDesignById(id: ID!): SupRefDesign
  "Search a specific reference designs by its unique identifiers."
  supRefDesignByIds(ids: [ID!]!): [SupRefDesign!]
  "Search a specific reference design by its unique name."
  supRefDesignByName(name: String!): SupRefDesign
  "Search a reference designs."
  supRefDesigns(q: String! filter: SupRefDesignFilterInput start: Int! = 0 limit: Int! = 10): SupRefDesignResultSet!
  "Search a specific parts by reference design unique identifier and part's designators."
  supRefParts(refDesignId: ID! designators: [String!] start: Int! = 0 limit: Int! = 50): [SupRefPart!]
  "Search a specific software project by its unique identifier."
  supSoftwareProjectById(id: ID!): SupSoftwareProject
  "Search a specific software project by its unique identifier."
  supSoftwareProjectsByIds(ids: [ID!]!): [SupSoftwareProject]!
  "List a reference solutions."
  supSoftwareProjects(q: String start: Int! = 0 limit: Int! = 10 filter: SupSoftwareProjectFilterInput): [SupSoftwareProject]!
  "Search a specific solution template by its unique identifier."
  supSolutionTemplateById(id: ID!): SupSolutionTemplate
  "Search a specific solution template by its unique identifier."
  supSolutionTemplatesByIds(ids: [ID!]!): [SupSolutionTemplate]!
  "List a solution templates."
  supSolutionTemplates(q: String start: Int! = 0 limit: Int! = 10): [SupSolutionTemplate]!
  "Search a specific solution template by application identifier."
  supSolutionTemplatesByApplicationId(id: String!): [SupSolutionTemplate]!
  "Search a specific solution template by its unique identifier."
  supSolutionTemplateApplicationById(id: ID!): SupSolutionTemplateApplication
  "Search a specific solution template by its application identifier."
  supSolutionTemplateApplicationByApplicationId(id: String!): SupSolutionTemplateApplication
  "get a the quotes from previously submitted metadata"
  manRapidQuotes(id: ID!): ManRapidQuoteResponse
  manRapidQuoteRequest(id: ID!): ManRapidQuoteRequest
  manOrder(orderId: ID!): ManOrder
  manAssembly(id: ID!): ManAssembly
  manListProjectOrders(id: ID!): [ManOrder]
  manAltimadeLogin(gsid: ID): String
  manBomResolution(projectId: ID! quoteRequestId: ID!): ManBomResolution
  manOrderEventById(id: ID!): ManOrderEvent
  manProjectFeatures(input: ManProjectFeatureInput!): ManFeatures
  "Get details about the organization(s) the current user belongs to."
  admOrganizations: [AdmOrganization!]!
  "Gets a single application by its unique identifier."
  admApplicationById(id: String!): AdmApplication
  datBomPart(item: DatBomItemInput!): DatBomPartsResult!
  datBomParts(items: [DatBomItemInput!]!): [DatBomPartsResult!]!
  datBomPartHistories(partIds: [String!]!): [DatBomPartHistory]!
  datBomDuplicateAnalyses(items: [DatBomPartItemInput!]!): [DatBomAnalysis!]!
  datBomAnalyses(items: [DatBomPartItemInput!]!): [DatBomAnalysis!]!
  datBomCategoryIdsByDesignator(designators: [String!]!): [DatBomCategory]!
  "Get an SCR Job with a specific id"
  datScrJob("The id of the job" jobId: String!): DatScrJob!
  "Get a list of SCR jobs."
  datScrJobs("The list of specific job ids. Use `null` to get all of them." jobIds: [String!]): [DatScrJob!]!
  "Get link to a downloadable SCR report."
  datScrReport("ID of the SCR job" jobId: String!): DatScrReport!
  "Get current metered usage statistics."
  datScrUsage: DatScrUsage
  "Grouped SCR historical procurability data for parts."
  datScrIpnPartInfo("List of part IDs, as returned from an Octopart supply data query." partIds: [String!]! "Estimated Annual Usage (EAU) as a number of pieces." eau: Long!): DatScrIpnPartInfo!
  "SCR data, including historical procurability, recent market availability and future prediction, for a set of parts."
  datScrPartInfos("List of part ID - Estimated Annual Usage (EAU) pairs." parts: [DatScrPartInfoInput!]!): [DatScrPartInfo]!
  "Information about the model parameters involved in SCR calculations."
  datScrModelInfo: DatScrModelInfo!
  datEddiLatestEdition: DatEddiEdition!
  datEddiEditions(where: DatEddiEditionFilterInput): [DatEddiEdition!]!
  supOctocart(items: [SupOctocartPartsBySellerInput!]! country: String = "US" currency: String = "USD"): [SupOctocartLink!]!
  datRepReports(companyId: String! "Returns the first N elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last N elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String where: IDatRepReportFilterInput order: [IDatRepReportSortInput!]): DatRepReportsConnection
  datRepDownloadableFile(companyId: String! reportId: String!): DatRepDownloadableFile
  datRepOctopartReportTypes: [DatRepOctopartReportType!]!
  datRepOctopartReportRequests(companyId: String!): [DatRepOctopartReportRequest!]!
}

type Mutation {
  "Creates a new comment."
  desCreateComment(input: DesCreateCommentInput!): DesCreateCommentPayload!
  "Permanently deletes the specified comment."
  desDeleteComment(input: DesDeleteCommentInput!): DesDeleteCommentPayload!
  "Updates the specified comment."
  desUpdateComment(input: DesUpdateCommentInput!): DesUpdateCommentPayload!
  "Creates a new comment thread."
  desCreateCommentThread(input: DesCreateCommentThreadInput!): DesCreateCommentThreadPayload!
  "Permanently deletes a comment thread."
  desDeleteCommentThread(input: DesDeleteCommentThreadInput!): DesDeleteCommentThreadPayload!
  "Updates the specified footprint. This will create a new revision of the footprint, and reset the lifecycle state."
  desUpdateFootprint(input: DesUpdateFootprintInput!): DesUpdateFootprintPayload!
  "Creates and releases the specified component template."
  desReleaseComponentTemplate(input: DesReleaseComponentTemplateInput!): DesReleaseComponentTemplatePayload!
  "Updates the specified component template."
  desUpdateComponentTemplate(input: DesUpdateComponentTemplateInput!): DesUpdateComponentTemplatePayload!
  "Updates parameters for the specified component (creates a new revision)."
  desUpdateComponentRevisionParameters(input: DesUpdateComponentRevisionParametersInput!): DesUpdateComponentRevisionParametersPayload!
  "Updates item parameters for the specified component (does not affect the revision)."
  desUpdateComponentItemParameters(input: DesUpdateComponentItemParametersInput!): DesUpdateComponentItemParametersPayload!
  "Updates the permissions for the associated folder."
  desUpdateFolderPermissions(input: DesUpdateFolderPermissionsInput!): DesUpdateFolderPermissionsPayload!
  "Updates life cycle state for the provided component."
  desUpdateComponentLifeCycleState(input: DesUpdateComponentLifeCycleStateInput!): DesUpdateComponentLifeCycleStatePayload!
  "Updates life cycle state for the provided footprint."
  desUpdateFootprintLifeCycleState(input: DesUpdateFootprintLifeCycleStateInput!): DesUpdateFootprintLifeCycleStatePayload!
  "Creates a folder in the library."
  desCreateFolder(input: DesCreateFolderInput!): DesCreateFolderPayload!
  "Updates the specified folder in the library."
  desUpdateFolder(input: DesUpdateFolderInput!): DesUpdateFolderPayload!
  "Moves the specified folder in the library."
  desMoveFolder(input: DesMoveFolderInput!): DesMoveFolderPayload!
  "Deletes the specified folder from the library."
  desDeleteFolder(input: DesDeleteFolderInput!): DesDeleteFolderPayload!
  "Creates a footprint."
  desCreateFootprint(input: DesCreateFootprintInput!): DesCreateFootprintPayload!
  "Updates the specified component's symbol (does not affect the revision)."
  desUpdateComponentSymbol(input: DesUpdateComponentSymbolInput!): DesUpdateComponentSymbolPayload!
  "Adds the specified footprint to a component (does not affect the revision)."
  desAddFootprintToComponent(input: DesAddFootprintToComponentInput!): DesAddFootprintToComponentPayload!
  "Removes the specified footprint from a component (does not affect the revision)."
  desRemoveFootprintFromComponent(input: DesRemoveFootprintFromComponentInput!): DesRemoveFootprintFromComponentPayload!
  "Upgrades components to use the latest symbol revision. This operation updates the link to the symbol and does not create new component revisions."
  desUpgradeComponentsToLatestSymbol(input: DesUpgradeComponentsToLatestSymbolInput!): DesUpgradeComponentsToLatestSymbolPayload!
  "Upgrades components to use the latest footprint revision. This operation updates the link to the footprint and does not create new component revisions."
  desUpgradeComponentsToLatestFootprint(input: DesUpgradeComponentsToLatestFootprintInput!): DesUpgradeComponentsToLatestFootprintPayload!
  "Adds part choices of the specified component."
  desAddComponentPartChoices(input: DesAddComponentPartChoicesInput!): DesAddComponentPartChoicesPayload!
  "Removes part choices of the specified component."
  desRemoveComponentPartChoices(input: DesRemoveComponentPartChoicesInput!): DesRemoveComponentPartChoicesPayload!
  "Releases the specified component."
  desReleaseComponent(input: DesReleaseComponentInput!): DesReleaseComponentPayload!
  "Creates a symbol."
  desCreateSymbol(input: DesCreateSymbolInput!): DesCreateSymbolPayload!
  "Updates life cycle state for the provided symbol."
  desUpdateSymbolLifeCycleState(input: DesUpdateSymbolLifeCycleStateInput!): DesUpdateSymbolLifeCycleStatePayload!
  "Updates the specified symbol. This will create a new revision of the symbol, and reset the lifecycle state."
  desUpdateSymbol(input: DesUpdateSymbolInput!): DesUpdateSymbolPayload!
  "Creates a project task. A task is a job activity in Altium 365."
  desCreateProjectTask(input: DesCreateProjectTaskInput!): DesCreateTaskPayload!
  "Creates a workspace task. A task is a job activity in Altium 365."
  desCreateWorkspaceTask(input: DesCreateWorkspaceTaskInput!): DesCreateTaskPayload!
  "Deletes the task specified by its node ID."
  desDeleteTask(input: DesDeleteTaskInput!): DesDeleteTaskPayload!
  "Updates the specified task."
  desUpdateTask(input: DesUpdateTaskInput!): DesUpdateTaskPayload!
  "Creates a new comment for the specified task."
  desCreateTaskComment(input: DesCreateTaskCommentInput!): DesCreateTaskCommentPayload!
  "Deletes the specified task comment."
  desDeleteTaskComment(input: DesDeleteTaskCommentInput!): DesDeleteTaskCommentPayload!
  "Updates the specified task comment."
  desUpdateTaskComment(input: DesUpdateTaskCommentInput!): DesUpdateTaskCommentPayload!
  "Uploads the project zip file."
  desUploadProject(input: DesUploadProjectInput!): DesUploadProjectPayload!
  "*PROTOTYPE, SUBJECT TO CHANGE*"
  desUploadCollaborationSimulation(input: DesUploadCollaborationSimulationInput!): DesUploadCollaborationSimulationPayload!
  "Uploads the specified collaboration."
  desUploadCollaboration(input: DesUploadCollaborationInput!): DesUploadCollaborationPayload!
  "Updates the permissions for the associated project."
  desUpdateProjectPermissions(input: DesUpdateProjectPermissionsInput!): DesUpdateProjectPermissionsPayload!
  "Link\/unlink A365 project with requirements block component."
  desSetProjectRequirementsBlock(input: DesSetProjectRequirementsBlockInput!): DesSetProjectRequirementsBlockPayload!
  "Updates parameters for the specified project (does not affect the revision)."
  desUpdateProjectParameters(input: DesUpdateProjectParametersInput!): DesUpdateProjectParametersPayload!
  "Updates a specific result block."
  desUpdateReuseBlock(input: DesUpdateReuseBlockInput!): DesUpdateReuseBlockPayload!
  "Creates a user."
  desCreateUser(input: DesCreateUserInput!): DesCreateUserPayload!
  "Deletes the specified user."
  desDeleteUser(input: DesDeleteUserInput!): DesDeleteUserPayload!
  "Updates the specified user properties."
  desUpdateUser(input: DesUpdateUserInput!): DesUpdateUserPayload!
  "Creates a new user group."
  desCreateUserGroup(input: DesCreateUserGroupInput!): DesCreateUserGroupPayload!
  "Deletes the specified user group."
  desDeleteUserGroup(input: DesDeleteUserGroupInput!): DesDeleteUserGroupPayload!
  "Updates the specified user group."
  desUpdateUserGroup(input: DesUpdateUserGroupInput!): DesUpdateUserGroupPayload!
  "Adds users to the specified group."
  desAddUsersToGroup(input: DesAddUsersToGroupInput!): DesAddUsersToGroupPayload!
  "Removes users from the specified group."
  desRemoveUsersFromGroup(input: DesRemoveUsersFromGroupInput!): DesRemoveUsersFromGroupPayload!
  "Launches a workflow. Workflows allow you to automate design processes, and are created in Altium 365."
  desLaunchWorkflow(input: DesLaunchWorkflowInput!): DesLaunchWorkflowPayload!
  "Terminates a workflow. Workflows allow you to automate design processes, and are created in Altium 365."
  desTerminateWorkflows(input: DesTerminateWorkflowsInput!): DesTerminateWorkflowsPayload!
  "Creates the provided life cycle definition, with associated states, stages and state transitions."
  desCreateLifeCycleDefinition(input: DesCreateLifeCycleDefinitionInput!): DesCreateLifeCycleDefinitionPayload!
  "Updates the defined life cycle definition with those provided."
  desUpdateLifeCycleDefinition(input: DesUpdateLifeCycleDefinitionInput!): DesUpdateLifeCycleDefinitionPayload!
  "Deletes the provided life cycle definitions."
  desDeleteLifeCycleDefinition(input: DesDeleteLifeCycleDefinitionInput!): DesDeleteLifeCycleDefinitionPayload!
  "Creates a revision naming scheme."
  desCreateRevisionNamingScheme(input: DesCreateRevisionNamingSchemeInput!): DesCreateRevisionNamingSchemePayload!
  "Updates a revision naming scheme."
  desUpdateRevisionNamingScheme(input: DesUpdateRevisionNamingSchemeInput!): DesUpdateRevisionNamingSchemePayload!
  "Deletes the revision naming scheme."
  desDeleteRevisionNamingScheme(input: DesDeleteRevisionNamingSchemeInput!): DesDeleteRevisionNamingSchemePayload!
  "Updates the value associated with the specified setting."
  desUpdateSetting(input: DesUpdateSettingInput!): DesUpdateSettingPayload!
  "Creates a manufacture package."
  desCreateManufacturePackage(input: DesCreateManufacturePackageInput!): DesCreateManufacturePackagePayload!
  "Creates a job that exports the specified project data."
  desCreateProjectExportJob(input: DesCreateProjectExportJobInput!): DesCreateProjectExportJobPayload!
  "Internal mutation to store Altium content vault metadata."
  supCreateContentVaultMetadata(input: SupCreateContentVaultMetadataInput!): SupCreateContentVaultMetadataPayload!
  "Create a new evaluation kit."
  supEvalKitCreateEvalKit(input: SupEvalKitCreateEvalKitInput!): SupEvalKitCreateEvalKitPayload!
  "Update a evaluation kit."
  supEvalKitUpdateEvalKit(input: SupEvalKitUpdateEvalKitInput!): SupEvalKitUpdateEvalKitPayload!
  "Delete a evaluation kit."
  supEvalKitDeleteEvalKit(input: SupEvalKitDeleteEvalKitInput!): SupEvalKitDeleteEvalKitPayload!
  "Create a new solution template."
  supSoftwareProjectCreateSoftwareProject(input: SupSoftwareProjectCreateSoftwareProjectInput!): SupSoftwareProjectCreateSoftwareProjectPayload!
  "Update a solution template."
  supSoftwareProjectUpdateSoftwareProject(input: SupSoftwareProjectUpdateSoftwareProjectInput!): SupSoftwareProjectUpdateSoftwareProjectPayload!
  "Delete a solution template."
  supSoftwareProjectDeleteSoftwareProject(input: SupSoftwareProjectDeleteSoftwareProjectInput!): SupSoftwareProjectDeleteSoftwareProjectPayload!
  "Create a new solution template."
  supSolutionTemplateCreateSolutionTemplate(input: SupSolutionTemplateCreateSolutionTemplateInput!): SupSolutionTemplateCreateSolutionTemplatePayload!
  "Update a solution template."
  supSolutionTemplateUpdateSolutionTemplate(input: SupSolutionTemplateUpdateSolutionTemplateInput!): SupSolutionTemplateUpdateSolutionTemplatePayload!
  "Delete a solution template."
  supSolutionTemplateDeleteSolutionTemplate(input: SupSolutionTemplateDeleteSolutionTemplateInput!): SupSolutionTemplateDeleteSolutionTemplatePayload!
  "Create a new solution template application."
  supSolutionTemplateCreateSolutionTemplateApplication(input: SupSolutionTemplateCreateSolutionTemplateApplicationInput!): SupSolutionTemplateCreateSolutionTemplateApplicationPayload!
  "Update a new solution template application."
  supSolutionTemplateUpdateSolutionTemplateApplication(input: SupSolutionTemplateUpdateSolutionTemplateApplicationInput!): SupSolutionTemplateUpdateSolutionTemplateApplicationPayload!
  "Delete a solution template application."
  supSolutionTemplateDeleteSolutionTemplateApplication(input: SupSolutionTemplateDeleteSolutionTemplateApplicationInput!): SupSolutionTemplateDeleteSolutionTemplateApplicationPayload!
  manCreateRapidQuoteRequest(qty: Int! meta: ManBoardMetaInput! shipping: ManShippingDetailsInput): ManRapidQuoteResponse
  "for a manufacturer to return a rapid quote reponse"
  manRespondRapidQuoteRequest("Unique request identifier" id: ID! "Quote Data From Manufactuerer" quote: ManQuoteInput!): ID!
  manRespondBulkRapidQuoteRequest(id: ID! quotes: [ManQuoteInput!]!): ID!
  manUpdateBomResolution(projectId: ID! quoteRequestId: ID! newSelections: [ManPartSelectionInput!]): ManBomResolution
  manCreateAssembly(quoteRequest: ID! commitId: ID projectId: ID!): ManCreateAssemblyResponse
  manCreateOrder(qty: Int assemblyId: ID!): ManCreateOrderResponse
  manUpdateOrderQty(orderId: ID! qty: Int!): ManOrder
  manUpdateOrderShipping(orderId: ID! shipping: ManShippingDetailsInput!): ManOrder
  "accept quote, confirm order as placed. "
  manAcceptOrderQuote(orderId: ID! quoteId: ID! paymentOptions: ManPaymentSelectionInput): ManOrder
  manInsertOrderEvent(id: ID! event: ManOrderEventType attributes: String): ManOrder
  manInsertOrderEmsAcceptEvent(input: ManOrderEmsAcceptInput!): ManOrder
  manInsertOrderShipUpdateEvent(input: ManOrderShipEstimateInput!): ManOrder
  manInsertOrderReviewEvent(input: ManOrderReviewInput!): ManOrder
  manInsertOrderBatchedEvent(input: ManOrderBatchedInput!): ManOrder
  manInsertOrderPartsOrderedEvent(input: ManOrderPartsOrderedInput!): ManOrder
  manInsertOrderPcbsOrderedEvent(input: ManOrderPcbsOrderedInput!): ManOrder
  manInsertOrderPartsReceivedEvent(input: ManOrderPartsReceivedInput!): ManOrder
  manInsertOrderPcbsReceivedEvent(input: ManOrderPcbsReceivedInput!): ManOrder
  manInsertOrderProcessStartEvent(input: ManOrderProcessStartInput!): ManOrder
  manInsertOrderShippedEvent(input: ManOrderShippedInput!): ManOrder
  manInsertOrderConsignmentDetailsEvent(input: ManOrderConsignmentDetailsInput!): ManOrder
  "Send a message to another application."
  admEvtSendAppNotification(input: AdmEvtSendAppNotificationInput!): AdmEvtSendAppNotificationPayload!
  "Create a new SCR processing run for a given CSV file."
  datScrCreateJob(input: DatScrCreateJobInput!): DatScrCreateJobPayload!
  "Delete an SCR job and any corresponding reports."
  datScrDeleteJob(input: DatScrDeleteJobInput!): DatScrDeleteJobPayload!
}

type Subscription {
  desOnCommentUpdated(input: DesOnCommentUpdatedInput!): DesCommentNotification!
}

"The node interface is implemented by entities that have a global unique identifier."
interface Node {
  id: ID!
}

"Payload associated with adding part choices for a component."
type DesAddComponentPartChoicesPayload {
  "The new component (revision) created with revision control enabled."
  newComponentId: ID!
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with adding a footprint to a component."
type DesAddFootprintToComponentPayload {
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with adding users to group."
type DesAddUsersToGroupPayload {
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Area in mm^2 and mils^2. Mils are one thousandth of an inch."
type DesArea {
  x: Float!
  "Area in mm^2."
  xMm2: Decimal!
  "Area in mm^2 and mils^2. Mils are one thousandth of an inch."
  xMils2: Decimal!
}

"Assembly drawing files display all components on the board in their assembled locations, with corresponding designators."
type DesAssemblyDrawings {
  "Assembly drawing files."
  assemblyDrawingFiles: [DesDownloadableFile!]!
  "Package name."
  packageName: String
  "Package download URL."
  downloadUrl: String
}

"A Bill of Materials (BOM) contains a list of all of the parts needed for the assembly of a PCB."
type DesBom implements Node {
  id: ID! @deprecated(reason: "Use `desWipVariantById` and `desReleaseVariantById` in order to access BOM.")
  bomItems: [DesBomItem!]! @deprecated(reason: "Use `items`.")
  "The list of BOM items returned by pages."
  items("Returns the first N elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last N elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String): DesBomItemConnection
}

"A Bill of Materials (BOM) item contains usage information for a unique component on the PCB."
type DesBomItem {
  "The detailed component information for this BOM item."
  component: DesComponent!
  "The total number of times this item is used."
  quantity: Int!
  "The list of each instance of this BOM item."
  bomItemInstances: [DesBomItemInstance!]!
}

"A connection to a list of items."
type DesBomItemConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [DesBomItemEdge!]
  "A flattened list of the nodes."
  nodes: [DesBomItem!]
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type DesBomItemEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DesBomItem!
}

"A Bill of Materials (BOM) item instance contains information for one specific usage of the item."
type DesBomItemInstance {
  "An alternate component used in this variant."
  alternateComponent: DesComponent
  "The unique label for this item."
  designator: String!
  "The variant use status for this item."
  isFitted: Boolean!
}

"Lines in your board where the design is folded at assembly."
type DesCadBendingLine {
  "Defines the sequence that the bends are folded in at assembly."
  foldIndex: Int!
  "The distance away from the bend surface that the bending center point is located."
  radius: Int!
  "The angle in degrees that the surface of the flex region is to bend."
  angle: Float!
  "The regions affected by the bend."
  affectedRegions: [String!]
  "Line starting point."
  startPoint: DesCadPoint!
  "Line ending point."
  endPoint: DesCadPoint!
}

"An item instance containing information a 3D model."
type DesCadBoard3DBodyModelData {
  "File path for 3D model."
  modelFilePath: String
  "File hash for 3D model."
  modelFileHash: String
  "Identifier on server for 3D model."
  modelIdOnServer: String
  "Display name for 3D model."
  modelDisplayName: String
  "Local test file name for 3D model."
  localTestFileName: String
  "3D model file extension."
  modelFileExtension: String
  "File path net name."
  modelNetName: String
  "Part name for 3D model."
  modelPartName: String
  "True if ECAD provides the raw 3D model."
  isEcadProvidesRaw3DModel: Boolean!
  "3D model color."
  color: Long
  "3D model opacity."
  opacity: Float
  "The token for getting URL by `DesLibrary.downloadUrlsByTokens`."
  downloadToken: String
}

"Information about the board area."
type DesCadBoardArea {
  "Unique identifier for CAD board area."
  uniqueId: String
  "Comment for CAD board area."
  comment: String
  "True if CAD board area restricts via."
  restrictsVia: Boolean!
  "True if CAD board area restricts track."
  restrictsTrack: Boolean!
  "True if CAD board area restricts copper."
  restrictsCopper: Boolean!
  "True if CAD board area restricts SMD pad."
  restrictsSMDPad: Boolean!
  "True if CAD board area restricts TH pad."
  restrictsTHPad: Boolean!
  "CAD board area placement."
  placement: DesCadBoardComponentPlacement!
  "JSON serialized *GeometricShape*."
  shapeJson: String
  "Board object type."
  objectType: DesCadBoardObjectType!
  "Board object rotation."
  rotation: Float!
  "Board object location."
  location: DesCadPoint!
  "Object designator."
  designator: String
}

"Information about a CAD board component."
type DesCadBoardComponent {
  "Identifier for CAD board component."
  id: String
  "Variant name for CAD board component."
  variantName: String
  "Placement of CAD board component."
  placement: DesCadBoardComponentPlacement!
  "True if CAD board component is locked."
  isLocked: Boolean!
  "True if CAD board component is a free 3D body."
  isFree3DBody: Boolean!
  "Board region names for CAD board component."
  boardRegionName: String
  "Deepening of CAD board component."
  deepening: Int!
  "True if CAD board component MCAD uses its own 3D body."
  isMcadUsesOwn3DBody: Boolean!
  "CAD board component free 3D body rotation (X)."
  free3DBodyRotationX: Float!
  "CAD board component free 3D body rotation (Y)."
  free3DBodyRotationY: Float!
  "CAD board component free 3D body rotation (Z)."
  free3DBodyRotationZ: Float!
  "CAD board component free 3D body standoff height."
  free3DBodyStandoffHeight: Int!
  "In case component contains single 3D body, the body's position relative to the component's origin point is stored here."
  modelInComponentTransform: DesCadBodyTransformation
  "In case the component contains a single 3D body AND no conversion was performed when exporting to a 3D model, the 3D model's position relative to board is stored here."
  innerBodyRelativeToBoardTransform: DesCadBodyTransformation
  "Board object type."
  objectType: DesCadBoardObjectType!
  "Board object rotation."
  rotation: Float!
  "Board object location."
  location: DesCadPoint!
  "Object designator."
  designator: String
}

"Information about a CAD board component type."
type DesCadBoardComponentType {
  "CAD board component type identifier."
  id: String
  "CAD board component type internal identifier."
  internalId: String
  "CAD board component type item GUID."
  itemGuid: String
  "CAD board component type revision GUID."
  revisionGuid: String
  "CAD board component type company component identifier."
  companyComponentId: String
  "CAD board component type library reference."
  libraryReference: String
  "True if CAD board component type is from local PCB library."
  isFromLocalPcbLibrary: Boolean!
  "Name of DMS component."
  dmsComponentName: String
  "CAD board component type body shape."
  bodyShape: DesCadComponentBodyShape
  "CAD board component type properties."
  properties: [DesCadProperty!]
  "CAD board component type components."
  components: [DesCadBoardComponent!]
}

"Information about a copper layer on the CAD board."
type DesCadBoardCopperLayer {
  "CAD board copper layer name."
  name: String
  "CAD board copper layer platform layer identifier."
  platformLayerId: Int!
  "CAD board copper layer thickness."
  thickness: Int!
  "True if CAD board copper layer is pad and via barrels special layer."
  isPadAndViaBarrelsSpecialLayer: Boolean!
  "CAD board copper layer models."
  models: [DesCadBoard3DBodyModelData!]
}

"Information about a copper layer region on the CAD board."
type DesCadBoardCopperRegion {
  "CAD board copper region layer name."
  layerName: String
  "CAD board copper region type."
  regionType: DesCadBoardCopperRegionType!
  "JSON serialized array of *GeometricShape*."
  outlineShapesJson: String
  "JSON serialized array of *GeometricShape*."
  holeShapesJson: String
}

"Information about a cutout on the CAD board."
type DesCadBoardCutout {
  "JSON serialized *GeometricShape*."
  shapeJson: String
  "CAD board cut abstruct unique identifier."
  uniqueId: String
  "Original designator of CAD board cut abstruct."
  originalDesignator: String
  "CAD board cut abstruct associated component designator."
  associatedComponentDesignator: String
  "Board object type."
  objectType: DesCadBoardObjectType!
  "Board object rotation."
  rotation: Float!
  "Board object location."
  location: DesCadPoint!
  "Object designator."
  designator: String
}

"Information about a hole on the CAD board component."
type DesCadBoardHole {
  "CAD board hole type."
  holeType: DesCadHoleType!
  "CAD board hole diameter."
  diameter: Int!
  "CAD board counter size."
  counterSize: Int!
  "CAD board hole counter depth."
  counterDepth: Int!
  "CAD board hole counter angle."
  counterAngle: Float!
  "CAD board hole counter type."
  counterType: DesCadCounterType!
  "True if CAD board hole is plated."
  isPlated: Boolean!
  "CAD board hole size."
  size: DesCadPoint!
  "CAD board cut abstruct unique identifier."
  uniqueId: String
  "Original designator of CAD board cut abstruct."
  originalDesignator: String
  "CAD board cut abstruct associated component designator."
  associatedComponentDesignator: String
  "Board object type."
  objectType: DesCadBoardObjectType!
  "Board object rotation."
  rotation: Float!
  "Board object location."
  location: DesCadPoint!
  "Object designator."
  designator: String
}

"Information about a layer on the CAD board component."
type DesCadBoardLayer {
  "CAD board layer name."
  name: String
  "CAD board platform layer identifier."
  platformLayerId: Int!
  "CAD board layer thickness."
  thickness: Int!
  "CAD board layer type."
  layerType: DesCadBoardLayerType!
  "CAD board layer position."
  layerPosition: DesCadBoardLayerPosition!
  "CAD board layer category."
  layerCategory: DesCadBoardLayerCategory!
  "CAD board layer physical category."
  layerPhysicalCategory: DesCadBoardLayerPhysicalCategory!
  "CAD board layer component placement."
  layerComponentPlacement: DesCadBoardLayerComponentPlacement!
  "CAD board layer dielectric type."
  layerDielectricType: DesCadBoardLayerDielectricType!
}

"Information about a CAD board region."
type DesCadBoardRegion {
  "CAD board region name."
  name: String
  "CAD board region layer bottom coordinate (Z)."
  regionLayerZBottom: Int!
  "CAD board region layer top coordinate (Z)."
  regionLayerZTop: Int!
  "True if CAD board region is flexible."
  isFlex: Boolean!
  "True if CAD board region is locked 3D."
  isLocked3D: Boolean!
  "CAD board region color."
  color: Long!
  "CAD board region internal point."
  internalPoint: DesCadPoint!
  "JSON serialized *ComplexShape*."
  shapeJson: String
  "CAD board region layers."
  layers: [DesCadBoardLayer!]
}

"Information about a track on the CAD board."
type DesCadBoardTrack {
  "CAD board track net name."
  netName: String
  "CAD board track layer name."
  layerName: String
  "CAD board track width."
  width: Int!
  "CAD board track points."
  points: [DesCadPoint!]!
}

"Information about a variant of the CAD board."
type DesCadBoardVariant {
  "CAD board variant unique identifier."
  uniqueId: String
  "CAD board variant name."
  name: String
  "CAD board variant description."
  description: String
  "CAD board variant properties."
  properties: [DesCadProperty!]
  "CAD board variant variations."
  variations: [DesCadComponentVariation!]
}

"Information about variants of the CAD board."
type DesCadBoardVariants {
  "Component type variant library for CAD board variants."
  componentTypeVariantLibrary: [DesCadBoardComponentType!]
  "CAD board variants."
  variants: [DesCadBoardVariant!]
}

"Information about a via on the CAD board."
type DesCadBoardVia {
  "CAD board via start layer name."
  startLayerName: String
  "CAD board via end layer name."
  endLayerName: String
  "CAD board via copper diameter."
  copperDiameter: Int!
  "CAD board via hole diameter."
  holeDiameter: Int!
  "CAD board hole location."
  location: DesCadPoint!
}

"Information about a transformation of the CAD board."
type DesCadBodyTransformation {
  translationX: Float!
  translationY: Float!
  translationZ: Float!
  rotationX: Float!
  rotationY: Float!
  rotationZ: Float!
  scaleX: Float!
  scaleY: Float!
  scaleZ: Float!
}

"Information about the body shape of a CAD board component."
type DesCadComponentBodyShape {
  "CAD component body height."
  height: Int!
  "True if CAD component body is hidden."
  isHidden: Boolean!
  "True if CAD component is bodyless on ECAD."
  isBodylessOnEcad: Boolean!
  "JSON serialized *GeometricShape*."
  shapeJson: String
  "CAD component model data."
  modelData: DesCadBoard3DBodyModelData
}

"Information about a variation of a CAD board component."
type DesCadComponentVariation {
  "CAD component variation designator."
  designator: String
  "CAD component variation rotation."
  rotation: Float!
  "CAD component variant kind."
  variantKind: DesCadComponentVariationKind!
  "CAD component type identifier."
  componentTypeId: String
  "CAD component variation placement."
  placement: DesCadBoardComponentPlacement!
  "CAD component variation location."
  location: DesCadPoint!
  "In case the component contains a single 3D body, the body's position relative to the component's origin point is stored here."
  modelInComponentTransform: DesCadBodyTransformation
}

"Information about a CAD design file."
type DesCadDesign {
  "CAD design board thickness."
  boardThickness: Int!
  "CAD design workflow state."
  workflowState: DesCadWorkflowState!
  "CAD design file name."
  designFileName: String
  "CAD design variant ID."
  designVariantId: String
  "CAD design variant name."
  designVariantName: String
  "Mode of export for CAD design."
  layersExportMode: DesCadLayersExportMode!
  "True if CAD design has hatched copper polygons."
  hasHatchedCopperPolygons: Boolean!
  "CAD design board color."
  boardColor: Long!
  "CAD design board core color."
  boardCoreColor: Long
  "CAD design board core opacity."
  boardCoreOpacity: Float
  "CAD design minimal height of the components shown."
  minimalHeightComponentsShown: Int!
  "True if CAD design is a RF20 design."
  isRF20Design: Boolean!
  "CAD design copper export features."
  copperExportFeatures: [DesCadBoardCopperExportFeature!]!
  "CAD design collaboration flags."
  collaborationFlags: [DesCadBoardCollaborationFlag!]!
  "CAD design board origin."
  boardOrigin: DesCadPoint!
  "CAD design board offset MCAD to ECAD origin."
  boardOffsetMcadToEcadOrigin: DesCadPoint!
  "CAD design coordinates system translation."
  coordinateSystemTranslation: DesCadPoint!
  "CAD design properties."
  properties: [DesCadProperty!]
  "CAD design component types."
  componentTypes: [DesCadBoardComponentType!]
  "CAD design holes."
  holes: [DesCadBoardHole!]
  "CAD design cutouts."
  cutouts: [DesCadBoardCutout!]
  "CAD design copper layers."
  copperLayers: [DesCadBoardCopperLayer!]
  "CAD design copper regions."
  copperRegions: [DesCadBoardCopperRegion!]
  "JSON serialized *ComplexShape*."
  boardOutlineJson: String
  "CAD design board split lines."
  boardSplitLines: [DesCadSplitLine!]
  "CAD design board regions."
  boardRegions: [DesCadBoardRegion!]
  "CAD design board bending lines."
  boardBendingLines: [DesCadBendingLine!]
  "CAD design board areas."
  boardAreas: [DesCadBoardArea!]
  "CAD design board layers."
  boardLayers: [DesCadBoardLayer!]
  "CAD design tracks."
  tracks: [DesCadBoardTrack!]
  "CAD design vias."
  vias: [DesCadBoardVia!]
  "CAD design variants."
  variants: DesCadBoardVariants
  "CAD design messages."
  messages: [String!]
}

"Information about a CAD board point."
type DesCadPoint {
  "CAD point coordinate (X)."
  x: Int!
  "CAD point coordinate (Y)."
  y: Int!
  "CAD point coordinate (Z)."
  z: Int!
}

"Information about a property in CAD."
type DesCadProperty {
  "CAD property name."
  name: String!
  "CAD property value."
  value: String
}

"Information about a CAD split line."
type DesCadSplitLine {
  "CAD split line region name (left)."
  leftRegionName: String
  "CAD split line region name (right)."
  rightRegionName: String
  "JSON serialized *ComplexShape*."
  shapeJson: String
  "Line starting point."
  startPoint: DesCadPoint!
  "Line ending point."
  endPoint: DesCadPoint!
}

"ECAD, MCAD or ESD revision data."
type DesCollaborationRevision {
  "Revision download data."
  downloadableFile: DesDownloadableFile!
  "The user who created this revision."
  createdBy: DesUser!
  "*PROTOTYPE, SUBJECT TO CHANGE*"
  design: DesCadDesign
  "Revision comment."
  comment: String!
  "Creation time."
  createdAt: DateTime!
}

"A connection to a list of items."
type DesCollaborationRevisionConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [DesCollaborationRevisionEdge!]
  "A flattened list of the nodes."
  nodes: [DesCollaborationRevision!]
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type DesCollaborationRevisionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DesCollaborationRevision!
}

"*PROTOTYPE, SUBJECT TO CHANGE*"
type DesCollaborationSimulationFile {
  fileTypeName: String!
  downloadUrl: String!
}

"*PROTOTYPE, SUBJECT TO CHANGE*"
type DesCollaborationSimulationRevision {
  files: [DesCollaborationSimulationFile!]!
  createdBy: DesUser!
  metadata: String!
  createdAt: DateTime!
}

"A connection to a list of items."
type DesCollaborationSimulationRevisionConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [DesCollaborationSimulationRevisionEdge!]
  "A flattened list of the nodes."
  nodes: [DesCollaborationSimulationRevision!]
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type DesCollaborationSimulationRevisionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DesCollaborationSimulationRevision!
}

"Information in HEX and RGB for the color of an item."
type DesColor {
  "Color value (HEX)."
  hexString: String!
  "Color value (RGB)."
  rgbString: String!
}

"A comment is one of remarks associated with a comment thread or task."
type DesComment {
  "The user who created the comment."
  createdBy: DesUser!
  "The user who modified the comment."
  modifiedBy: DesUser!
  "The users mentioned by this comment."
  mentions: [DesMention!]!
  "The comment reference ID."
  commentId: String!
  "The comment text."
  text: String!
  "The creation date."
  createdAt: DateTime!
  "The last modification date."
  modifiedAt: DateTime!
}

"A comment context provides additional information about associations for a comment thread."
type DesCommentContext {
  "The reference identifier for the document associated with a comment thread."
  documentId: String
  "The reference identifier for an object associated with a comment thread."
  objectId: String
  "The area associated with a comment thread."
  area: DesRectangle!
  "The release identifier associated with a comment thread."
  releaseId: String
}

"Notification for comment."
type DesCommentNotification {
  "Comment notification action."
  action: String!
  "Comment notification data."
  data: DesCommentNotificationData!
}

"Information contained in comment notification data."
type DesCommentNotificationData {
  "Comment notification project identifier."
  projectId: String!
  "Comment notification document identifier."
  documentId: String
  "Comment notification document name."
  documentName: String
  "Comment thread identifier."
  commentThreadId: String!
  "Comment thread date."
  threadDate: String!
  "Comment thread data."
  threadData: String
  "Comment thread status."
  threadStatus: String
  "Comment identifier."
  commentId: String!
  "Comment author."
  commentAuthor: String
  "Comment date."
  commentDate: String!
  "Comment text."
  commentText: String
}

"A comment thread contains an initial remark associated with the design and a collection of replies."
type DesCommentThread {
  "The account information for the owner of any action or response to this comment thread."
  assignedTo: DesUser
  "The account information for who created this comment thread."
  createdBy: DesUser!
  "The account information for who most recently modified this comment thread."
  modifiedBy: DesUser!
  "The web address to download the screenshot associated with the creation of this comment thread."
  originalStateScreenshotUrl: String
  "The list of replies associated with this comment thread."
  comments: [DesComment!]!
  "The reference identifier for this comment thread (used by `desCreateComment`, `desDeleteComment`, `desUpdateComment`)."
  commentThreadId: String!
  "Comment thread status."
  status: Int!
  "The `DateTime` for the creation of this comment thread."
  createdAt: DateTime!
  "The `DateTime` for the most recent modification of this comment thread."
  modifiedAt: DateTime!
  "The sequence number of this comment thread."
  threadNumber: Int!
  "The information about properties related to this comment thread."
  context: DesCommentContext!
}

"A component contains the parametric details of a PCB part."
type DesComponent implements Node {
  "The node ID used by `desComponentById`. Unmanaged components may be not found."
  id: ID!
  "The component folder."
  folder: DesFolder
  "The list of the part choices associated with this component."
  manufacturerParts: [DesManufacturerPart!]!
  "More component data, consider using only with `desComponentById`."
  details: DesComponentDetails!
  "Component 3D model."
  model3D: DesModel3D
  "The component type classification for this component."
  componentType: DesComponentType
  "The user who created this component."
  createdBy: DesUser!
  "The library label for this component."
  name: String!
  "The additional information for this component."
  comment: String!
  "The summary of function or other performance details for this component."
  description: String!
  "The `DateTime` when this component was created."
  createdAt: DateTime!
  "The `DateTime` when this component was last modified."
  modifiedAt: DateTime!
  "Gets true if the component is managed."
  isManaged: Boolean!
  "The component revision."
  revision: DesRevision!
}

"A connection to a list of items."
type DesComponentConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [DesComponentEdge!]
  "A flattened list of the nodes."
  nodes: [DesComponent!]
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

type DesComponentDetails {
  "The component item internal identifier."
  itemInternalId: String!
  "The list of revision level parameters from the latest revision. Parameter types are unknown (`NONE`) for unmanaged components."
  parameters: [DesComponentParameter!]!
  "The list of parameters describing the item."
  itemParameters: [DesComponentParameter!]!
  "The list of component symbols."
  symbols: [DesSymbol!]!
  "The list of component footprints."
  footprints: [DesFootprint!]!
  "The list of component simuation models."
  simulations: [DesSimulation!]!
  "The list of component datasheets."
  datasheets: [DesDatasheet!]!
}

"An edge in a connection."
type DesComponentEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DesComponent!
}

"Parameter describing a component."
type DesComponentParameter {
  "Component parameter type. "
  type: DesParameterType!
  "Parameter name."
  name: String!
  "Parameter value."
  value: String!
}

"Information about a component template."
type DesComponentTemplate implements Node {
  "The node ID (used by `desComponentTemplateById`)."
  id: ID!
  "Component template name."
  name: String!
  "Component template description."
  description: String!
  "Component template folder."
  folder: DesFolder
  "Component template latest revision."
  latestRevision: DesComponentTemplateRevision!
}

"A connection to a list of items."
type DesComponentTemplateConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [DesComponentTemplateEdge!]
  "A flattened list of the nodes."
  nodes: [DesComponentTemplate!]
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type DesComponentTemplateEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DesComponentTemplate!
}

"Component template revision information."
type DesComponentTemplateRevision {
  "Component template revision name."
  name: String!
  "Creation date for component template revision."
  createdAt: DateTime!
  "Component template revision comment."
  comment: String!
  "Component template revision description."
  description: String!
  "Component template revision downloadable file."
  downloadableFile: DesDownloadableFile!
}

"Represents a component type classification in the component library."
type DesComponentType implements Node {
  "The node identifier for this component type."
  id: ID! @deprecated(reason: "Use `componentTypeId` instead.")
  "The reference identifier for this component type."
  componentTypeId: String!
  "The display name of the component type."
  name: String!
  "The parent of this component type in the hierarchy."
  parent: DesComponentType
  "The user this was created by."
  createdBy: DesUser!
  "The user this was last updated by."
  updatedBy: DesUser!
  "The `DateTime` this was created."
  createdAt: DateTime!
  "The `DateTime` this was last updated."
  updatedAt: DateTime!
}

"Payload associated with creating a comment."
type DesCreateCommentPayload {
  "Comment identifier."
  commentId: String!
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with creating a comment thread."
type DesCreateCommentThreadPayload {
  "Comment thread identifier."
  commentThreadId: String!
  "Comment identifier."
  commentId: String!
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with creating a folder."
type DesCreateFolderPayload {
  "ID of the created folder."
  id: ID @deprecated(reason: "Use `folderId` instead.")
  "Reference identifier of the created folder."
  folderId: String
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with creating footprint."
type DesCreateFootprintPayload {
  "The created footprint identifier."
  footprintId: ID
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with creating a life cycle definition."
type DesCreateLifeCycleDefinitionPayload {
  "Life cycle definition identifier."
  id: ID!
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with creating a manufacture package."
type DesCreateManufacturePackagePayload {
  "Job identifier for creating a manufacture package."
  jobId: ID!
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with creating a project export job."
type DesCreateProjectExportJobPayload {
  "The job ID to be used by `desProjectExportJob`."
  projectExportJobId: String
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with creating a revision naming scheme."
type DesCreateRevisionNamingSchemePayload {
  "ID of the created revision naming scheme."
  id: ID!
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with creating a symbol."
type DesCreateSymbolPayload {
  "Identifier of the created symbol."
  id: ID!
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with creating a task comment."
type DesCreateTaskCommentPayload {
  "Task comment."
  comment: DesComment
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with creating a task."
type DesCreateTaskPayload {
  "The created task."
  task: DesTask!
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with creating a user group."
type DesCreateUserGroupPayload {
  "User group identifier."
  id: ID!
}

"Payload associated with creating a user."
type DesCreateUserPayload {
  "Workspace user identifier."
  userId: String!
}

"A component datasheet."
type DesDatasheet implements Node {
  "Datasheet node identifier."
  id: ID!
  "ECAD entity data download URL."
  dataDownloadUrl: String!
  "The user this entity was created by."
  createdBy: DesUser!
  "The user this entity was last updated by."
  updatedBy: DesUser!
  "ECAD entity folder."
  folder: DesFolder
  "Item internal identifier."
  itemInternalId: String!
  "Revision internal identifier."
  revisionInternalId: String!
  "ECAD entity name."
  name: String!
  "ECAD entity comment."
  comment: String!
  "ECAD entity description."
  description: String!
}

"A connection to a list of items."
type DesDatasheetConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [DesDatasheetEdge!]
  "A flattened list of the nodes."
  nodes: [DesDatasheet!]
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type DesDatasheetEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DesDatasheet!
}

"Payload associated with deleting a comment."
type DesDeleteCommentPayload {
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with deleting a comment thread."
type DesDeleteCommentThreadPayload {
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with deleting a folder."
type DesDeleteFolderPayload {
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with deleting a life cycle definition."
type DesDeleteLifeCycleDefinitionPayload {
  "Life cycle definition identifier."
  id: ID!
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with deleting a revision naming scheme."
type DesDeleteRevisionNamingSchemePayload {
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with deleting a task comment."
type DesDeleteTaskCommentPayload {
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with deleting a task."
type DesDeleteTaskPayload {
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with deleting a user group."
type DesDeleteUserGroupPayload {
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with deleting a user."
type DesDeleteUserPayload {
  "Payload errors."
  errors: [DesPayloadError!]!
}

"A design manages all of the schematic, PCB, and BOM content for a project."
type DesDesign {
  "The list of variants contained in your work in progress (WIP) in this design."
  variants(where: DesWipVariantFilterInput): [DesWipVariant!]!
  "The list of published versions of the design grouped into pages."
  releases("Returns the first N elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last N elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String where: DesReleaseFilterInput): DesReleaseConnection
  workInProgress: DesWorkInProgress! @deprecated(reason: "Use `variants` instead.")
}

"Design exchange models and downloads."
type DesDesignExchange {
  "Design exchange 3D models."
  models3D: [DesModel3D!]!
  "Design exchange downloadable files."
  downloadableFile: DesDownloadableFile!
}

"A design item is a specific instance of a part used in the design."
type DesDesignItem implements Node {
  "The node identifier for this project (used by `desDesignItemById`)."
  id: ID! @deprecated(reason: "`SchId` and `PcbId` are now available.")
  "The schematic identifier."
  schId: String
  "The PCB identifier."
  pcbId: String
  "The detailed component information for this design item."
  component: DesComponent
  "*PROTOTYPE, SUBJECT TO CHANGE*"
  mesh3D: DesMesh3D
  "The list of all comment threads related to this design item."
  commentThreads: [DesCommentThread!]
  "The unique label for this design item."
  designator: String!
  "The summary of function or other performance details for this design item."
  description: String!
  "The additional information for this design item."
  comment: String!
  "The layer(side) placement for this design item."
  layer: DesLayer
  "The planar location for this design item."
  position: DesPosition2D!
  area: DesRectangle @deprecated(reason: "Use `boundingBox`.")
  "The axis-aligned bounding box."
  boundingBox: DesRectangle
  "Design area footprint name."
  footprintName: String!
  "The rotation in degrees."
  rotation: Decimal
  "The list of parameters describing the design item."
  parameters: [DesDesignItemParameter!]!
  "The list of connection targets for this design item."
  pads: [DesPad!]!
  "The list of multiple layer connections for this design item."
  vias: [DesVia!]!
  "The list of conductor segments for this design item."
  tracks(where: DesTrackFilterInput): [DesTrack!]!
}

"A connection to a list of items."
type DesDesignItemConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [DesDesignItemEdge!]
  "A flattened list of the nodes."
  nodes: [DesDesignItem!]
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type DesDesignItemEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DesDesignItem!
}

"A parameter describing the design item."
type DesDesignItemParameter {
  "Parameter name."
  name: String!
  "Parameter value."
  value: String!
}

"Information and URL for a downloadable file."
type DesDownloadableFile {
  "Downloadable file name."
  fileName: String!
  "Downloadable file relative path."
  relativePath: String!
  "Download URL for file."
  downloadUrl: String!
}

"A folder of downloadable files."
type DesDownloadableFolder {
  "The folder relative path."
  relativePath: String!
  "Download URL for the whole folder."
  downloadUrl: String!
  "Downloadable files of this folder."
  files: [DesDownloadableFile!]!
}

"Payload associated with error."
type DesErrorPayload {
  "Error message."
  message: String!
}

"Information about a specific folder."
type DesFolder implements Node {
  "Folder identifier."
  id: ID! @deprecated(reason: "Use `folderId` instead.")
  "Folder name."
  name: String!
  "Folder path."
  path: String!
  "Folder description."
  description: String!
  "Folder parent."
  parent: DesFolder
  "The user this folder was created by."
  createdBy: DesUser!
  "The user this folder was last updated by."
  updatedBy: DesUser!
  "The item naming scheme template this folder uses."
  itemNamingSchemeTemplate: String
  "Folder permissions."
  folderPermissions: [DesFolderPermission!]!
  "The `DateTime` this folder was created."
  createdAt: DateTime!
  "The `DateTime` this folder was last updated at."
  updatedAt: DateTime!
  "Folder type."
  folderType: DesFolderType!
  "The reference identifier for this folder."
  folderId: String!
}

"Information about a folder permission."
type DesFolderPermission {
  "The permission scope to differentiate different permission types."
  scope: DesPermissionScope!
  "The `DesUserGroup` this permission is associated with."
  group: DesUserGroup
  "The user this permission is associated with."
  user: DesUser
  "Tells if this permission allows reading of the associated folder."
  canRead: Boolean!
  "Tells if this permission allows editing the associated folder."
  canEdit: Boolean!
  "Tells if this permission allows creation of objects within the associated folder."
  canCreate: Boolean!
  "Tells if this permission allows deletion of the associated folder."
  canDelete: Boolean!
  "The name of this permission."
  name: String!
}

"A component footprint. Footprints define the space a component occupies."
type DesFootprint implements Node {
  "Footprint node identifier."
  id: ID!
  pins: [DesPin!]! @deprecated(reason: "Not implemented and may be removed.")
  "The life cycle state information."
  lifeCycleState: DesLifeCycleState!
  "ECAD entity full size image URL."
  imageFullSizeUrl: String!
  "ECAD entity thumbnail image URL."
  imageThumbnailUrl: String!
  "ECAD entity data download URL."
  dataDownloadUrl: String!
  "The user this entity was created by."
  createdBy: DesUser!
  "The user this entity was last updated by."
  updatedBy: DesUser!
  "ECAD entity folder."
  folder: DesFolder
  guid: String! @deprecated(reason: "Use `RevisionInternalId` instead.")
  "Item internal identifier."
  itemInternalId: String!
  "Revision internal identifier."
  revisionInternalId: String!
  "ECAD entity name."
  name: String!
  "ECAD entity comment."
  comment: String!
  "ECAD entity description."
  description: String!
}

"A connection to a list of items."
type DesFootprintConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [DesFootprintEdge!]
  "A flattened list of the nodes."
  nodes: [DesFootprint!]
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type DesFootprintEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DesFootprint!
}

"Gerber information. Gerber files store the shape and location data for all the elements on the PCB layout."
type DesGerber {
  "Gerber files."
  gerberFiles: [DesDownloadableFile!]!
  "Package name."
  packageName: String
  "Package download URL."
  downloadUrl: String
}

"Gerber X2 information. Gerber X2 files store the shape and location data for all the elements on the PCB layout."
type DesGerberX2 {
  "Gerber X2 files."
  gerberX2Files: [DesDownloadableFile!]!
  "Package name."
  packageName: String
  "Package download URL."
  downloadUrl: String
}

"IPC 2581 information. IPC 2581 files hold manufacturing data."
type DesIpc2581 {
  "IPC 2581 files."
  ipc2581Files: [DesDownloadableFile!]!
  "Package name."
  packageName: String
  "Package download URL."
  downloadUrl: String
}

"Payload associated with launching a workflow."
type DesLaunchWorkflowPayload {
  "Workflow identifier."
  id: String!
  "Status of the launched workflow."
  status: Int!
}

"Information about a specific layer in the PCB."
type DesLayer {
  "Layer name."
  name: String!
  "Layer thickness."
  thickness: DesSize
  "Layer dielectric constant."
  dielectricConstant: Decimal
  "Layer copper weight."
  copperWeight: DesWeight
  "The copper area."
  copperArea: DesArea @deprecated(reason: "No longer used - always returns null.")
  "The ratio of copper area to PCB area."
  copperRatio: Decimal @deprecated(reason: "No longer used - always returns null.")
  "Layer material."
  material: String
  "Layer nets."
  nets: [DesNet!]!
  "Layer type."
  layerType: DesLayerType!
  "Layer properties."
  layerProperties: [DesLayerProperty!]!
}

"A property describing a layer."
type DesLayerProperty {
  "Layer property name."
  name: String!
  "Layer property text."
  text: String!
  "Layer property size."
  size: DesSize
}

"Information about your library. All component data in A365 is stored in your library."
type DesLibrary {
  "The user that created the library."
  createdBy: DesUser!
  "The user that updated the library."
  updatedBy: DesUser!
  "Gets library folders."
  folders(where: DesFolderFilterInput): [DesFolder!]!
  "Gets library components."
  components("Returns the first N elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last N elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String where: DesComponentFilterInput): DesComponentConnection
  "Gets library component templates."
  componentTemplates("Returns the first N elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last N elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String): DesComponentTemplateConnection
  "Gets library reuse blocks."
  reuseBlocks("Returns the first N elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last N elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String): DesReuseBlockConnection
  "*PROTOTYPE, SUBJECT TO CHANGE*"
  downloadUrlsByTokens(tokens: [String!]!): [String]!
  "Gets library symbols."
  symbols("Returns the first N elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last N elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String where: DesSymbolFilterInput): DesSymbolConnection
  "Gets library footprints."
  footprints("Returns the first N elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last N elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String where: DesFootprintFilterInput): DesFootprintConnection
  "Gets library datasheets."
  datasheets("Returns the first N elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last N elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String where: DesDatasheetFilterInput): DesDatasheetConnection
  name: String!
  description: String!
  version: String!
  eventChannel: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

"Revision naming scheme details obtained by `desLifeCycleDefinitions`."
type DesLifeCycleDefinition {
  "The user this life cycle definition was created by."
  createdBy: DesUser!
  "The user this life cycle definition was last updated by."
  updatedBy: DesUser!
  "The `DesLifeCycleStateTransition` list for this life cycle definition."
  stateTransitions: [DesLifeCycleStateTransition!]!
  "The node ID."
  id: ID!
  "The reference ID for this life cycle definition."
  lifeCycleDefinitionId: String! @deprecated(reason: "Use `id` instead.")
  "The name of this life cycle definition."
  name: String!
  "The `DesContentTypeKind` list for this life cycle definition."
  contentTypes: [DesContentTypeKind!]!
  "The `DateTime` this life cycle definition was created."
  createdAt: DateTime!
  "The `DateTime` this life cycle definition was last updated."
  updatedAt: DateTime!
  "The `DesLifeCycleStage` list for this life cycle definition."
  stages: [DesLifeCycleStage!]!
  "Type of life cycle management."
  lifeCycleManagementType: DesLifeCycleManagementType!
  "Tells if this life cycle definition is automatically assigned the first `DesLifeCycleState` when a revision is released."
  isRevisionSchemeAssigned: Boolean!
  "Returns `true` if the life cycle definition is controlled per content type."
  isControlledPerContentType: Boolean!
}

"Information about the life cycle stage."
type DesLifeCycleStage {
  "The user this life cycle stage was created by."
  createdBy: DesUser!
  "The user this life cycle stage was last updated by."
  updatedBy: DesUser!
  "The reference ID for this life cycle stage."
  lifeCycleStageId: String!
  "The name of this life cycle stage."
  name: String!
  "The stage index for this life cycle stage."
  stageIndex: Int!
  "The `DateTime` this life cycle stage was created."
  createdAt: DateTime!
  "The `DateTime` this life cycle stage was last updated at."
  updatedAt: DateTime!
  "The `DesLifeCycleState` list for this life cycle stage."
  states: [DesLifeCycleState!]!
}

"Information about the life cycle state."
type DesLifeCycleState {
  "The user this life cycle state was created by."
  createdBy: DesUser!
  "The user this life cycle state was last updated by."
  updatedBy: DesUser!
  "The reference ID for this life cycle state."
  lifeCycleStateId: String!
  "The name of this life cycle state."
  name: String!
  "The description of this life cycle state."
  description: String!
  "The state index for this life cycle state."
  stateIndex: Int!
  "The `DateTime` this life cycle state was created."
  createdAt: DateTime!
  "Determines whether this life cycle state is the first of all the states for the associated life cycle definition."
  isInitialState: Boolean!
  "The background color for this life cycle state."
  backgroundColor: DesColor!
  "The foreground color for this life cycle state."
  foregroundColor: DesColor!
  "Determines whether items in this life cycle state are allowed to be used in a design."
  isAllowedInDesign: Boolean!
  "Determines whether this life cycle state is visible in the Altium Designer vault panel."
  isVisible: Boolean!
  "The `DateTime` this life cycle state was last updated at."
  updatedAt: DateTime!
}

"Information about the life cycle state transition."
type DesLifeCycleStateTransition {
  "The user this life cycle state transition was created by."
  createdBy: DesUser!
  "The user this life cycle state transition was last updated by."
  updatedBy: DesUser!
  "The `DesLifeCycleState` before the transition is applied."
  lifeCycleStateBefore: DesLifeCycleState
  "The `DesLifeCycleState` after the transition is applied."
  lifeCycleStateAfter: DesLifeCycleState
  "The controllers who are allowed to perform this transition. If using approvals, this will return null."
  controllers: [DesLifeCycleStateTransitionController!]
  "Determines whether the transition is publicly accessible."
  isPublic: Boolean!
  "The groups that must provide an approval for the transition to be applied. If using controlled transitions, this will return null."
  approvals: [DesLifeCycleStateTransitionApprovalGroup!]
  "The reference ID for this life cycle state transition."
  lifeCycleStateTransitionId: String!
  "The name of this life cycle state transition."
  name: String!
  "The `DateTime` this life cycle state transition was created."
  createdAt: DateTime!
  "The `DateTime` this life cycle state transition was last updated at."
  updatedAt: DateTime!
  "The format string for the transition menu in Altium Designer."
  menuTextFormat: String!
  "Determines how the permissions for the state transition are managed."
  transitionKind: DesLifeCycleStateTransitionKind!
}

"Information about the life cycle state transition approval groups."
type DesLifeCycleStateTransitionApprovalGroup {
  "The name of this life cycle state transition approval group."
  name: String!
  "The controllers that can provide an approval for this life cycle state transition approval group."
  controllers: [DesLifeCycleStateTransitionController!]!
}

"Information about the life cycle state transition controllers."
type DesLifeCycleStateTransitionController {
  "The group this life cycle state transition controller is assigned to. It is null unless the scope is set to `GROUP`."
  group: DesUserGroup
  "The user this life cycle state transition controller is assigned to. It is null unless the scope is set to `USER`."
  user: DesUser
  "The name of this life cycle state transition controller."
  name: String!
  "The scope of this life cycle state transition controller."
  scope: DesPermissionScope!
}

"Information about the manufacture package."
type DesManufacturePackage implements Node {
  "The node identifier for this project (used by `desManufacturePackageById`)."
  id: ID! @deprecated(reason: "Will be removed in the future.")
  "Manufacture package name."
  name: String!
  "Manufacture package download URL."
  downloadUrl: String!
}

"Information about the manufacture package creation job."
type DesManufacturePackageCreationJob {
  "Manufacture package creation job identifier."
  id: String!
  "When the manufacture package creation job was created."
  createdAt: DateTime!
  "Manufacture package creation job payload."
  payload: DesManufacturePackageCreationJobPayload!
  "Status of the manufacture package creation job."
  status: DesJobStatus!
}

"Payload associated with a manufacture package creation job."
type DesManufacturePackageCreationJobPayload {
  "Manufacture package identifier."
  packageId: ID
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Manufacturer part information."
type DesManufacturerPart {
  supplierParts: [DesSupplierPart!]!
  "The Octopart ID."
  octopartId: String
  "The manufacturer company name."
  companyName: String!
  "The part number (MPN)."
  partNumber: String!
  "Manufacturer part priority."
  priority: Int!
}

"A reference to a user in a comment."
type DesMention {
  "The mentioned user."
  user: DesUser!
}

type DesMesh3D {
  "The downloadable file for the 3D mesh."
  glbFile: DesDownloadableFile
}

type DesModel3D {
  "The downloadable 3D model Parasolid file."
  parasolidFile: DesDownloadableFile
}

"Payload associated with moving a folder."
type DesMoveFolderPayload {
  "Payload errors."
  errors: [DesPayloadError!]!
}

"NC Drill file information."
type DesNcDrill {
  "NC Drill files."
  ncDrillFiles: [DesDownloadableFile!]!
  "Package name."
  packageName: String
  "Package download URL."
  downloadUrl: String
}

"Net information."
type DesNet {
  "Net name."
  name: String!
  "Net cumulative length."
  cumulativeLength: DesSize!
  "The layers associated with this net."
  layers: [DesLayer!]!
  "The pads associated with this net."
  pads: [DesPad!]!
  "The vias associated with this net."
  vias: [DesVia!]!
  "The tracks associated with this net."
  tracks(where: DesTrackFilterInput): [DesTrack!]!
}

"ODB file information."
type DesOdb {
  "ODB files."
  odbFiles: [DesDownloadableFile!]!
  "Package name."
  packageName: String
  "Package download URL."
  downloadUrl: String
}

"Pad information."
type DesPad {
  "The type of this pad."
  padType: DesPadType!
  "The layer associated with this pad."
  layer: DesLayer
  "The net associated with this pad."
  net: DesNet
  "The designator associated with this pad."
  designator: String
  "The global designator associated with this pad."
  globalDesignator: String
  "The radius of this pad."
  radius: Int
  "The rotation of this pad."
  rotation: Decimal
  "The plated status of this pad."
  isPlated: Boolean
  "The hole size of this pad."
  holeSize: DesSize!
  "The size of this pad."
  size: DesSize2D!
  "The shape of this pad."
  shape: DesPrimitiveShape
  "The position of this pad."
  position: DesPosition2D!
}

"Payload error."
type DesPayloadError {
  "Payload error message."
  message: String!
}

"A PCB contains design details of the physical product."
type DesPcb {
  "The details of the layer structure of this PCB."
  layerStack: DesStackup
  "The outline of this PCB."
  outline: DesPolygon!
  "PCB items, instances of `DesComponent`, returned by pages."
  designItems("**DEPRECATED** Use `where: {designator: {in: ...}}`." designators: [String!] "Returns the first N elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last N elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String where: DesDesignItemFilterInput): DesDesignItemConnection
  "The list of all electrically connected regions in this PCB."
  nets("An optional array of names to search." names: [String!]): [DesNet!]!
  "The list of all part connection targets in this PCB."
  pads: [DesPad!]!
  "The list of all conductor segments in this PCB."
  tracks(where: DesTrackFilterInput): [DesTrack!]!
  "The list of all multiple layer connections in this PCB."
  vias: [DesVia!]!
  "*PROTOTYPE, SUBJECT TO CHANGE*"
  mesh3D: DesMesh3D
  "The list of all comment threads related to this PCB."
  commentThreads: [DesCommentThread!]!
  "The reference identifier for this PCB."
  documentId: String!
  "The document file name."
  documentName: String!
  "The dimensions of the PCB outline."
  size: DesSize2D!
  "The total area contained by the PCB outline."
  area: DesArea!
  "The location of the coordinate system origin."
  origin: DesPosition2D!
}

"PCB assembly information and URLs to download files."
type DesPcbAssembly {
  "The name of the PCB assembly package."
  packageName: String!
  "Downloadable folders."
  folders: [DesDownloadableFolder!]!
  pickAndPlace: DesPickAndPlace! @deprecated(reason: "Use `folders`.")
  assemblyDrawings: DesAssemblyDrawings! @deprecated(reason: "Use `folders`.")
  "Download URL."
  downloadUrl: String!
  "Version."
  version: String!
  "Life cycle state name."
  lifeCycleStateName: String!
}

"PCB fabrication information and URLs to download files."
type DesPcbFabrication {
  "The name of the PCB fabrication package."
  packageName: String!
  "Downloadable folders."
  folders: [DesDownloadableFolder!]!
  "ODB files and download URL."
  odb: DesOdb! @deprecated(reason: "Use `folders`.")
  "IPC 2581 files and download URL."
  ipc2581: DesIpc2581! @deprecated(reason: "Use `folders`.")
  "Gerber files and download URL."
  gerber: DesGerber! @deprecated(reason: "Use `folders`.")
  "Gerber X2 files and download URL."
  gerberX2: DesGerberX2! @deprecated(reason: "Use `folders`.")
  "NC Drill files and download URL."
  ncDrill: DesNcDrill! @deprecated(reason: "Use `folders`.")
  "Test point files and download URL."
  testPoints: DesTestPoints! @deprecated(reason: "Use `folders`.")
  "Download URL."
  downloadUrl: String!
  "Version."
  version: String!
  "Life cycle state name."
  lifeCycleStateName: String!
}

"PCB Pick and Place files and download URL."
type DesPickAndPlace {
  "Pick and Place files."
  pickAndPlaceFiles: [DesDownloadableFile!]!
  "Package name."
  packageName: String
  "Package download URL."
  downloadUrl: String
}

"Pin properties."
type DesPin {
  "Pin display name. By default, a newly placed pin will be named using the designator value."
  name: String!
  "Description of pin."
  description: String!
  "The numerical identifier of the pin."
  designator: String!
  "Electrical type of the pin."
  electricalType: DesPinElectricalType!
  "Returns `true` if the pin is hidden."
  isHidden: Boolean!
}

"Polygon properties."
type DesPolygon {
  "Vertices of polygon."
  vertices: [DesPosition2D!]!
}

"2D positional information in mm and mils."
type DesPosition2D {
  "X in mm."
  xMm: Decimal!
  "Y in mm."
  yMm: Decimal!
  "X in mils. Mils are one thousandth of an inch."
  xMils: Decimal!
  "Y in mils. Mils are one thousandth of an inch."
  yMils: Decimal!
  "Positional coordinate (X)."
  x: Int!
  "Positional coordinate (Y)."
  y: Int!
}

"A project manages all development stages of the PCB\/PCA product lifecycle."
type DesProject implements Node {
  "The node identifier for this project (used by `desProjectById`)."
  id: ID!
  "The requirements block identifier."
  requirementsBlockId: String
  "The account information for who created this project."
  createdBy: DesUser!
  "The account information for who last modified this project."
  updatedBy: DesUser!
  "The list of the parameters describing this project."
  parameters("An optional list of parameter names to search." names: [String!]): [DesProjectParameter!]!
  "The web address to download a preview image for this project."
  previewUrl(isDirectLink: Boolean! = false): String!
  "The list of workflows associated with this project."
  workflows("An option to search workflows that have been modified after a specific `DateTime`." modifiedAfter: DateTime "Filter workflows by a variable." withVariable: DesWorkflowFilterByVariableInput "An option to search workflows that have been completed." isClosed: Boolean! = false where: DesWorkflowFilterInput): [DesWorkflow!]
  "The latest VCS revision."
  latestRevision: DesVcsRevision!
  "The list of VCS revisions."
  revisions("Returns the first N elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last N elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String): DesVcsRevisionConnection
  "The latest ECAD, MCAD or ESD revision. See also `desProjectCollaborationLatestRevision`."
  collaborationLatestRevision(domain: DesCollaborationDomain!): DesCollaborationRevision
  "ECAD, MCAD or ESD revisions returned by pages. See also `desProjectCollaborationRevisions`."
  collaborationRevisions(domain: DesCollaborationDomain! "Returns the first N elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last N elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String): DesCollaborationRevisionConnection
  projectPermissions: [DesProjectPermission!]!
  "The list of project tasks. For a particular project consider using the more effective query `desProjectTasks`."
  tasks: [DesTask!]!
  "The number of design variants."
  variantCount: Int!
  "The Altium 365 web address."
  url: String!
  "The Altium 365 workspace URL."
  workspaceUrl: String!
  "The reference identifier for this project."
  projectId: String!
  "The assigned name for this project."
  name: String
  "The summary of this project content or purpose."
  description: String
  "The project type."
  projectType: DesProjectType!
  "The `DateTime` when this project was created."
  createdAt: DateTime!
  "The `DateTime` when this project was last modified."
  updatedAt: DateTime!
  "The detailed design information for this project."
  design: DesDesign!
}

"A connection to a list of items."
type DesProjectConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [DesProjectEdge!]
  "A flattened list of the nodes."
  nodes: [DesProject!]
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type DesProjectEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DesProject!
}

type DesProjectExportJob {
  "The job current status."
  status: DesJobStatus!
  "Whet the job status is `ERROR`, the error message."
  reason: String
  "When the job status is `DONE`, the result zip file download URL."
  downloadUrl: String
}

"Payload associated with project node id."
type DesProjectIdPayload {
  id: ID!
}

"A parameter describing the project."
type DesProjectParameter {
  "Parameter name."
  name: String!
  "Parameter value."
  value: String!
}

"A permission associated with the project."
type DesProjectPermission {
  "The name of this project permission."
  name: String!
  "The user this project permission is associated with."
  user: DesUser
  "The permission scope to differentiate different permission types."
  scope: DesPermissionScope!
  "The `DesUserGroup` this permission is associated with."
  group: DesUserGroup
  "Tells if this permission allows reading of the associated project."
  canRead: Boolean!
  "Tells if this permission allows editing the associated project."
  canEdit: Boolean!
  "Tells if this permission allows creation of objects within the associated project."
  canCreate: Boolean!
  "Tells if this permission allows deletion of the associated project."
  canDelete: Boolean!
}

"Information about a project template."
type DesProjectTemplate implements Node {
  "The node ID (used by `desProjectTemplateById`)."
  id: ID!
  "Project template name."
  name: String!
  "Project template description."
  description: String!
  "Project template folder."
  folder: DesFolder
  "Project template latest revision."
  latestRevision: DesProjectTemplateRevision!
}

"A connection to a list of items."
type DesProjectTemplateConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [DesProjectTemplateEdge!]
  "A flattened list of the nodes."
  nodes: [DesProjectTemplate!]
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type DesProjectTemplateEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DesProjectTemplate!
}

"Project template revision information."
type DesProjectTemplateRevision implements Node {
  "Project template revision identifier."
  id: ID!
  "Project template revision name."
  name: String!
  "Creation date for project template revision."
  createdAt: DateTime!
  "Project template revision comment."
  comment: String!
  "Project template revision description."
  description: String!
  "Project template revision downloadable file."
  downloadableFile: DesDownloadableFile!
}

"Rectangle positional information."
type DesRectangle {
  "Rectangle corner point 1."
  pos1: DesPosition2D!
  "Rectangle corner point 2."
  pos2: DesPosition2D!
}

"A release is a published version of a design with additional generated files for manufacturing."
type DesRelease implements Node {
  "The identifier for this release (used by `desReleaseById`)."
  id: ID!
  "The list of variants contained in this release."
  variants(where: DesReleaseVariantFilterInput): [DesReleaseVariant!]!
  manufacturePackages: [DesManufacturePackage!]!
  "The `DateTime` when this release was created."
  createdAt: DateTime!
  "The summary of this release content or purpose."
  description: String!
  "The reference identifier for this release."
  releaseId: String!
}

"Payload associated with releasing component file."
type DesReleaseComponentPayload {
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with releasing a component template."
type DesReleaseComponentTemplatePayload {
  componentTemplateId: ID!
  "Payload errors."
  errors: [DesPayloadError!]!
}

"A connection to a list of items."
type DesReleaseConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [DesReleaseEdge!]
  "A flattened list of the nodes."
  nodes: [DesRelease!]
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type DesReleaseEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DesRelease!
}

"A variant contains a specific configuration of a base design."
type DesReleaseVariant implements Node {
  "The node identifier (used by `desReleaseVariantById`)."
  id: ID!
  "The project release package."
  downloadUrl: String!
  "The data needed for assembly of this published design variant."
  pcbAssembly: DesPcbAssembly
  "The data needed for fabrication of this published design variant."
  pcbFabrication: DesPcbFabrication
  "The Bill of Materials (BOM) for this published design variant."
  bom: DesBom
  "The PCB document for this design variant."
  pcb: DesPcb
  "The descriptive label for this design variant."
  name: String!
  "The list of schematic documents for this design variant."
  schematics(where: DesSchematicFilterInput): [DesSchematic!]!
}

"Payload associated with removing part choices for a component."
type DesRemoveComponentPartChoicesPayload {
  "The new component (revision) created with revision control enabled."
  newComponentId: ID!
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with removing a footprint from a component."
type DesRemoveFootprintFromComponentPayload {
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with removing users from a group."
type DesRemoveUsersFromGroupPayload {
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Reuse blocks are items that can be reused in future board-level design projects."
type DesReuseBlock implements Node {
  "Latest revision for a reuse block."
  latestRevision: DesReuseBlockRevision!
  "All revisions of the reuse block."
  revisions: [DesReuseBlockRevision!]!
  "The node identifier for this reuse block (used by `desReuseBlockById`)."
  id: ID!
  "Name of reuse block."
  name: String!
  "Description of reuse block."
  description: String!
}

"A connection to a list of items."
type DesReuseBlockConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [DesReuseBlockEdge!]
  "A flattened list of the nodes."
  nodes: [DesReuseBlock!]
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type DesReuseBlockEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DesReuseBlock!
}

"Reuse block revision information."
type DesReuseBlockRevision implements Node {
  "The circuitry in a PCB design including components and routing saved as a reuse block."
  pcbSnippet: DesDownloadableFile!
  "The circuitry on a single schematic sheet saved as a reuse block."
  schematicSnippet: DesDownloadableFile!
  "The life cycle state information."
  lifeCycleState: DesLifeCycleState!
  "The node identifier for this reuse block (used by `desReuseBlockRevisionById`)."
  id: ID!
  "The name of the reuse block revision."
  name: String!
  "The comment on a reuse block revision."
  comment: String!
  "The description for the reuse block revision."
  description: String!
}

"Revision details ID for later use or full details."
type DesRevision {
  "The revision details ID for `desRevisionDetailsById`. The instance may not exist for unmanaged components."
  id: ID! @deprecated(reason: "Use `revisionId` instead.")
  "The revision details or null for unmanaged components."
  details: DesRevisionDetails
  "The reference identifier for revision used in `desRevisionDetailsByRevisionId`. The instance may not exist for unmanaged components."
  revisionId: String!
}

"Revision details."
type DesRevisionDetails {
  "The life cycle state information of the revision."
  lifeCycleState: DesLifeCycleState!
  "Number of children associated with this revision."
  childCount: Int!
  "Reference file information and download URL."
  references: [DesDownloadableFile!]!
  "The number of parents associated with this revision."
  parentCount: Int!
  "The node ID."
  id: ID! @deprecated(reason: "Use `revisionId` instead.")
  "The reference identifier."
  revisionId: String!
  "Revision description."
  description: String
  "Revision comment."
  comment: String
  "The `DateTime` when this revision was created."
  createdAt: DateTime!
  "The `DateTime` when this revision was last modified."
  modifiedAt: DateTime!
  "The `DateTime` when this revision was released."
  releaseDate: DateTime!
}

"Revision naming scheme details obtained by `desRevisionNamingSchemes`. More information is available on revision naming schemes at: https:\/\/www.altium.com\/documentation\/altium-designer\/accessing-detailed-item-view#!revision_naming_scheme_dlg"
type DesRevisionNamingScheme {
  "The user this revision naming scheme was created by."
  createdBy: DesUser!
  "The user this revision naming scheme was last updated by."
  updatedBy: DesUser!
  "The node ID."
  id: ID!
  "The reference ID for this revision naming scheme."
  revisionNamingSchemeId: String! @deprecated(reason: "Use `id` instead.")
  "The name of this revision naming scheme."
  name: String!
  "The `DesContentTypeKind` list for this revision naming scheme."
  contentTypes: [DesContentTypeKind!]!
  "The `DateTime` this revision naming scheme was created."
  createdAt: DateTime!
  "The `DateTime` this revision naming scheme was last updated at."
  updatedAt: DateTime!
  "The `DesRevisionNamingSchemeLevel` list for this revision naming scheme."
  levels: [DesRevisionNamingSchemeLevel!]!
  "The separator used between item ID and revision ID."
  itemRevisionSeparator: String!
  "If true, the revision naming scheme is only applicable to objects of the content types specified by `contentTypes`."
  isControlledPerContentType: Boolean!
}

"Information on the revision naming scheme level."
type DesRevisionNamingSchemeLevel {
  "The user this revision naming scheme level was created by."
  createdBy: DesUser!
  "The user this revision naming scheme level was last updated by."
  updatedBy: DesUser!
  "The reference ID for this revision naming scheme level."
  revisionNameLevelId: String!
  "The name of this revision naming scheme level. In Altium Designer it is known as 'Caption'."
  name: String!
  "The `DateTime` this revision naming scheme level was created."
  createdAt: DateTime!
  "The `DateTime` this revision naming scheme level was last updated at."
  updatedAt: DateTime!
  "The minimum character length allowed for this revision naming scheme level."
  minimumWidth: Int!
  "The level index of this level in the revision naming scheme."
  levelIndex: Int!
  "The separator prefix character for this revision naming scheme level."
  levelSeparator: String!
  "The naming policy for this revision naming scheme level."
  revisionNamingPolicy: DesRevisionNamingPolicy!
  "The level sequence of this revision naming scheme level."
  levelSequence: String! @deprecated(reason: "Use `RevisionNamingPolicy` instead.")
}

"A schematic contains the design parts and logical connections."
type DesSchematic {
  "The list of all part instances used in this schematic grouped into pages."
  designItems("Returns the first N elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last N elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String where: DesDesignItemFilterInput): DesDesignItemConnection
  "The list of all comment threads related to this schematic."
  commentThreads: [DesCommentThread!]!
  "The reference identifier for this schematic."
  documentId: String!
  "The document file name."
  documentName: String!
}

type DesSetProjectRequirementsBlockPayload {
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Setting information."
type DesSetting {
  name: String!
  value: String!
}

"Projects and manufacture packages shared with user."
type DesSharedWithMe {
  projects("Returns the first N elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last N elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String where: DesSharedWithMeProjectInfoFilterInput): DesSharedWithMeProjectInfoConnection
  manufacturePackages: [DesManufacturePackage!]!
}

"Information about a project that is shared with the user."
type DesSharedWithMeProjectInfo {
  "The project or null if its workspace is deleted. Avoid this field on getting many projects at once. Consider using `projectId` and `desProjectById`."
  project: DesProject
  "The project node ID. Use it for getting the project by `desProjectById`."
  projectId: ID!
  "The project name."
  name: String!
  "The project description."
  description: String!
}

"A connection to a list of items."
type DesSharedWithMeProjectInfoConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [DesSharedWithMeProjectInfoEdge!]
  "A flattened list of the nodes."
  nodes: [DesSharedWithMeProjectInfo!]
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type DesSharedWithMeProjectInfoEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DesSharedWithMeProjectInfo!
}

"Component simulation information."
type DesSimulation {
  "ECAD entity data download URL."
  dataDownloadUrl: String!
  "The user this entity was created by."
  createdBy: DesUser!
  "The user this entity was last updated by."
  updatedBy: DesUser!
  "ECAD entity folder."
  folder: DesFolder
  guid: String! @deprecated(reason: "Use `RevisionInternalId` instead.")
  "Item internal identifier."
  itemInternalId: String!
  "Revision internal identifier."
  revisionInternalId: String!
  "ECAD entity name."
  name: String!
  "ECAD entity comment."
  comment: String!
  "ECAD entity description."
  description: String!
}

"Size in mm and mils."
type DesSize {
  "X value."
  x: Decimal!
  "Size in mm."
  xMm: Decimal!
  "Size in mils. Mils are one thousandth of an inch."
  xMils: Decimal!
}

"2D size in mm and mils."
type DesSize2D {
  "X value."
  x: Int!
  "Y value."
  y: Int!
  "X value in mm."
  xMm: Decimal!
  "X value in mils. Mils are one thousandth of an inch."
  xMils: Decimal!
  "Y value in mm."
  yMm: Decimal!
  "Y value in mils. Mils are one thousandth of an inch."
  yMils: Decimal!
}

"Information about layer stack."
type DesStack {
  name: String!
  layers: [DesLayer!]!
}

"Layer stackup properties and definition."
type DesStackup {
  "Type of stackup."
  stackupType: String!
  "Layer types in stackup."
  layerTypes: [DesLayerType!]!
  "Shows roughness of conductive layers."
  roughnessType: String!
  "Value of the surface roughness."
  roughnessFactorSR: String!
  "Roughness factor, characterizing the expected maximal increase in conductor losses due to the roughness effect. Default is 2."
  roughnessFactorRF: String!
  "Substacks that make a stackup."
  stacks: [DesStack!]!
}

"Information about supplier and part offers."
type DesSupplierPart {
  "The supplier company name."
  companyName: String!
  "The part number (SKU)."
  partNumber: String!
  "Use `prices` and `stocks` with library components only, e.g. `DesLibrary.components`, `desComponentById`."
  prices: [DesSupplierPrice!]
  "Use `prices` and `stocks` with library components only, e.g. `DesLibrary.components`, `desComponentById`."
  stocks: [DesSupplierStock!]
}

"Price information from supplier."
type DesSupplierPrice {
  "Currency of offer."
  currency: String!
  "Supplier offer price."
  price: Decimal!
  "Supplier offer price break. A price break is when the cost per item is decreased when larger quantities are ordered."
  breakQuantity: Int!
}

"Supplier inventory level."
type DesSupplierStock {
  "Region that this inventory level applies to."
  locationName: String!
  "Stock level value."
  quantity: Decimal!
}

"A component symbol. These represent the body and the pins on the physical component."
type DesSymbol implements Node {
  "Symbol node identifier."
  id: ID!
  "The list of pins."
  pins: [DesPin!]!
  "The life cycle state information."
  lifeCycleState: DesLifeCycleState!
  "ECAD entity full size image URL."
  imageFullSizeUrl: String!
  "ECAD entity thumbnail image URL."
  imageThumbnailUrl: String!
  "ECAD entity data download URL."
  dataDownloadUrl: String!
  "The user this entity was created by."
  createdBy: DesUser!
  "The user this entity was last updated by."
  updatedBy: DesUser!
  "ECAD entity folder."
  folder: DesFolder
  guid: String! @deprecated(reason: "Use `RevisionInternalId` instead.")
  "Item internal identifier."
  itemInternalId: String!
  "Revision internal identifier."
  revisionInternalId: String!
  "ECAD entity name."
  name: String!
  "ECAD entity comment."
  comment: String!
  "ECAD entity description."
  description: String!
}

"A connection to a list of items."
type DesSymbolConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [DesSymbolEdge!]
  "A flattened list of the nodes."
  nodes: [DesSymbol!]
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type DesSymbolEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DesSymbol!
}

type DesSystemDiagram {
  "The downloadable file for the system diagram."
  systemDiagramFile: DesDownloadableFile
}

"Task activities in Altium 365 workspace for workspace members."
type DesTask implements Node {
  "The assigned user."
  assignee: DesUser!
  "The user who created the task."
  createdBy: DesUser!
  "The user who modified the task."
  modifiedBy: DesUser!
  "The list of task comments."
  comments: [DesComment!]!
  "The node ID."
  id: ID!
  "The task ID shown in Altium 365."
  refId: String!
  "The task name."
  name: String!
  "The task description."
  description: String!
  "The task priority."
  priority: DesTaskPriority!
  "The task status."
  status: DesTaskStatus!
  "The creation date."
  createdAt: DateTime!
  "The last modification date."
  modifiedAt: DateTime!
}

"A connection to a list of items."
type DesTaskConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [DesTaskEdge!]
  "A flattened list of the nodes."
  nodes: [DesTask!]
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type DesTaskEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DesTask!
}

"Information about a team in a workspace."
type DesTeam {
  "List of users in the team."
  users: [DesUser!]!
  "List of user groups in the team."
  groups: [DesUserGroup!]!
}

"Error associated with terminating workflows."
type DesTerminateWorkflowsError {
  "Workflow identifier."
  id: String!
  "Workflow error message."
  message: String!
}

"Payload associated with terminating a workflow."
type DesTerminateWorkflowsPayload {
  "Errors associated with terminating workflows."
  errors: [DesTerminateWorkflowsError!]!
}

"Information for test points for PCB fabrication."
type DesTestPoints {
  "File information for test point files."
  testPointFiles: [DesDownloadableFile!]!
  "Package name."
  packageName: String
  "Package download URL."
  downloadUrl: String
}

"PCB design track information."
type DesTrack {
  "Layer associated with the track."
  layer: DesLayer
  "Net associated with the track."
  net: DesNet
  "Width of track."
  width: DesSize!
  "Positional information about the track start point."
  begin: DesPosition2D!
  "Positional information about the track end point."
  end: DesPosition2D!
}

"Payload associated with updating a comment."
type DesUpdateCommentPayload {
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with updating component item parameters."
type DesUpdateComponentItemParametersPayload {
  "Component identifier."
  componentId: ID!
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with updating a component life cycle state."
type DesUpdateComponentLifeCycleStatePayload {
  "Component identifier."
  componentId: ID!
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with updating component revision parameters."
type DesUpdateComponentRevisionParametersPayload {
  "Component identifier."
  componentId: ID!
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with updating the symbol of a component."
type DesUpdateComponentSymbolPayload {
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with updating a component template."
type DesUpdateComponentTemplatePayload {
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with updating a folder."
type DesUpdateFolderPayload {
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with updating folder permissions."
type DesUpdateFolderPermissionsPayload {
  "Folder identifier."
  folderId: ID! @deprecated(reason: "This value will soon change from folder node identifier to folder reference identifier (GUID).")
}

"Payload associated with updating a footprint life cycle state."
type DesUpdateFootprintLifeCycleStatePayload {
  "Footprint identifier."
  footprintId: ID!
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload of updating a footprint."
type DesUpdateFootprintPayload {
  "Identifier of the updated footprint."
  id: ID!
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with updating a life cycle definition."
type DesUpdateLifeCycleDefinitionPayload {
  "Life cycle definition identifier."
  id: ID!
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with updating project parameters."
type DesUpdateProjectParametersPayload {
  "Project identifier."
  projectId: ID!
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with updating project permissions."
type DesUpdateProjectPermissionsPayload {
  "Project identifier."
  projectId: ID!
}

"Payload associated with updating a reuse block."
type DesUpdateReuseBlockPayload {
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with updating revision naming scheme."
type DesUpdateRevisionNamingSchemePayload {
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with updating a setting."
type DesUpdateSettingPayload {
  "The setting that was updated."
  setting: DesSetting!
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with updating a symbol life cycle state."
type DesUpdateSymbolLifeCycleStatePayload {
  "Symbol identifier."
  symbolId: ID!
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload of updating a symbol."
type DesUpdateSymbolPayload {
  "Identifier of the updated symbol."
  id: ID!
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with updating a task comment."
type DesUpdateTaskCommentPayload {
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with updating a task."
type DesUpdateTaskPayload {
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with updating user group."
type DesUpdateUserGroupPayload {
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with updating a user."
type DesUpdateUserPayload {
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload for upgrading components to use the latest footprint revision."
type DesUpgradeComponentsToLatestFootprintPayload {
  "The number of components that were successfully upgraded."
  upgradedCount: Int!
  "The number of components that failed to upgrade."
  failedCount: Int!
  "The total number of components that were processed."
  totalProcessed: Int!
  "List of component identifiers that were upgraded."
  upgradedComponentIds: [ID!]!
  "List of component identifiers that failed to upgrade."
  failedComponentIds: [ID!]!
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload for upgrading components to use the latest symbol revision."
type DesUpgradeComponentsToLatestSymbolPayload {
  "The number of components that were successfully upgraded."
  upgradedCount: Int!
  "The number of components that failed to upgrade."
  failedCount: Int!
  "The total number of components that were processed."
  totalProcessed: Int!
  "List of component identifiers that were upgraded."
  upgradedComponentIds: [ID!]!
  "List of component identifiers that failed to upgrade."
  failedComponentIds: [ID!]!
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with uploading collaboration."
type DesUploadCollaborationPayload {
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with uploading collaboration simulation."
type DesUploadCollaborationSimulationPayload {
  "Payload errors."
  errors: [DesPayloadError!]!
}

"Payload associated with uploading project."
type DesUploadProjectPayload {
  "The unique project identifier."
  projectId: ID!
  "Payload errors."
  errors: [DesPayloadError!]!
}

"User details with the identifier and nullable extra fields."
type DesUser {
  "Null if the user no longer exists."
  pictureUrl(size: DesUserPictureSize): String
  "Null if the user no longer exists."
  groups: [DesUserGroup!]
  "The workspace specific user identifier."
  userId: String
  "The global user identifier. Common for this user across all workspaces."
  globalUserId: String
  "Null if the user no longer exists."
  userName: String
  "Null if the user no longer exists."
  email: String
  "Null if the user no longer exists."
  firstName: String
  "Null if the user no longer exists."
  lastName: String
}

"A user group information."
type DesUserGroup implements Node {
  "The node ID."
  id: ID!
  "The group name."
  name: String!
}

"VCS revision\/commit information."
type DesVcsRevision {
  "VCS revision identifier."
  revisionId: String!
  "VCS revision message."
  message: String!
  "User that created the VCS revision."
  author: String!
  "`DateTime` when VCS revision was created."
  createdAt: DateTime!
  "VCS revision files."
  files: [DesVcsRevisionFileChange!]!
}

"A connection to a list of items."
type DesVcsRevisionConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [DesVcsRevisionEdge!]
  "A flattened list of the nodes."
  nodes: [DesVcsRevision!]
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type DesVcsRevisionEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DesVcsRevision!
}

"Describes the file affected by a VCS revision."
type DesVcsRevisionFileChange {
  "VCS revision file change kind."
  kind: DesVcsChangeKind!
  "VCS revision file path."
  path: String!
}

"PCB design via information."
type DesVia {
  "Layer associated with via."
  layer: DesLayer
  "Net associated with via."
  net: DesNet
  "Layer information about the via start point."
  beginLayer: DesLayer
  "Positional information about the via end point."
  endLayer: DesLayer
  "Name of via."
  name: String
  "Via hole diameter."
  holeDiameter: DesSize!
  "Via pad diameter."
  padDiameter: DesSize!
  "Via shape."
  shape: DesPrimitiveShape
  "Positional information about the via."
  position: DesPosition2D!
}

"Weight in grams and ounces."
type DesWeight {
  x: Decimal!
  gram: Decimal!
  ounce: Decimal!
}

"A variant contains a specific configuration of a base design."
type DesWipVariant implements Node {
  "The node identifier (used by `desWipVariantById`)."
  id: ID! @deprecated(reason: "Use `ProjectId` and `Name` with `desWipVariantByVariantName` instead.")
  "The project identifier (used by `desWipVariantByVariantName`)."
  projectId: String! @deprecated(reason: "This is temporary to illustrate project identifier as GRID`.")
  designExchange: DesDesignExchange
  "The Bill of Materials (BOM) for this design variant."
  bom: DesBom
  "The system diagram for this design variant."
  systemDiagram: DesSystemDiagram
  "The PCB document for this design variant."
  pcb: DesPcb
  "The descriptive label for this design variant."
  name: String!
  "The list of schematic documents for this design variant."
  schematics(where: DesSchematicFilterInput): [DesSchematic!]!
}

"The most recent version of a design."
type DesWorkInProgress {
  "The list of variants contained in your work in progress (WIP) in this design."
  variants(where: DesWipVariantFilterInput): [DesWipVariant!]!
}

"A workflow manages the execution of a logical sequence of tasks."
type DesWorkflow {
  "The list of variables defined for this workflow."
  variables("An optional list of parameter names to search." names: [String!]): [DesWorkflowVariable!]!
  "The `DateTime` for the most recent changes for this workflow."
  modifiedAt: DateTime!
  "The reference identifier for this workflow."
  workflowId: String!
  "The name of the active task(s) for this workflow."
  state: String
  "The account information for the owner of any action or response needed for this workflow."
  assignee: String!
  "The account information for who created this workflow."
  createdBy: String!
  "The `DateTime` for the creation of this workflow."
  createdAt: DateTime!
  "The `DateTime` for the completion of this workflow."
  endedAt: DateTime
  "The label for this workflow."
  name: String!
  "The reference identifier for definition of this workflow."
  processDefinitionId: String!
  "The label for the definition of this workflow."
  processDefinitionName: String!
  "The current condition of this workflow."
  status: String!
}

"A workflow definition contains a logical sequence of tasks."
type DesWorkflowDefinition {
  "The list of variables need to launch this workflow definition."
  variables: [DesWorkflowVariable!]!
  "The reference identifier for this workflow definition."
  workflowDefinitionId: String!
  "The label for this workflow definition."
  name: String!
  "The account information for who created this workflow definition."
  createdBy: String!
  "The `DateTime` for the creation of this workflow definition."
  createdAt: DateTime!
}

"A variable belonging to the workflow."
type DesWorkflowVariable {
  "Type of variable."
  valueType: String
  "Workflow variable constraint. If it is \"required\", then the variable needs to be provided when launching a workflow with `desLaunchWorkflow`."
  constraint: String
  "Parameter name."
  name: String!
  "Parameter value."
  value: String!
}

"A workspace provides a flexible and secure method for managing design, manufacturing and supply content."
type DesWorkspace implements Node {
  "The node identifier for the workspace (used by `desWorkspaceById`)."
  id: ID!
  "The location of this workspace."
  location: DesWorkspaceLocation!
  "The resource managing components for this workspace."
  library: DesLibrary!
  "The configuration of this workspace."
  configuration: DesWorkspaceConfiguration!
  "The list of members authorized for this workspace."
  team: DesTeam!
  "The list of projects managed in this workspace."
  projects(where: DesProjectFilterInput): [DesProject!]!
  "The list of workflow definitions in this workspace."
  workflowDefinitions(where: DesWorkflowDefinitionFilterInput): [DesWorkflowDefinition!]
  "The list of workflows in this workspace."
  workflows("Filter workflows by a variable." withVariable: DesWorkflowFilterByVariableInput where: DesWorkflowFilterInput): [DesWorkflow!]
  "The list of workspace tasks. For a particular workspace consider using the more effective query `desWorkspaceTasks`."
  tasks: [DesTask!]!
  "The descriptive label for this workspace."
  name: String!
  "The web address of this workspace."
  url: String!
  "The ID of this workspace used for authorization."
  authId: String!
  "The summary of this workspace content or purpose."
  description: String
  "Tells if the workspace is the current user default."
  isDefault: Boolean!
}

"Information about workspace configuration."
type DesWorkspaceConfiguration {
  "Gets project templates."
  projectTemplates("Returns the first N elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last N elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String): DesProjectTemplateConnection
}

"A workspace provides a flexible and secure method for managing design, manufacturing and supply content."
type DesWorkspaceInfo {
  "The node identifier for the workspace (used by `desWorkspaceById`)."
  workspaceId: ID!
  "The descriptive label for this workspace."
  name: String!
  "The web address of this workspace."
  url: String!
  "The ID of this workspace used for authorization."
  authId: String!
  "The summary of this workspace content or purpose."
  description: String
  "Tells if the workspace is the current user default."
  isDefault: Boolean!
  "The location of this workspace."
  location: DesWorkspaceLocation!
}

"A region in which workspaces can be located."
type DesWorkspaceLocation {
  "The name of the location."
  name: String!
  "The preferred Nexar API URL to use for this location."
  apiServiceUrl: String!
  "The preferred files service URL to use for this location."
  filesServiceUrl: String!
}

"Information about pagination in a connection."
type PageInfo {
  "Indicates whether more edges exist following the set defined by the clients arguments."
  hasNextPage: Boolean!
  "Indicates whether more edges exist prior the set defined by the clients arguments."
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
  "When paginating forwards, the cursor to continue."
  endCursor: String
}

"Payload associated with errors."
type SupErrorPayload {
  "Error message."
  message: String!
}

"Nexar supply part data for internal use only."
type SupPartExtras {
  alternatives(first: Int! = 100): [SupPartExtras!]!
  partId: String!
  description: String
  isRohsCompliant: Boolean
  confidence: Float
  datasheetUrls: [String!]
  lifeCycle: SupPartLifeCycle!
  parameters: [SupPartExtrasParameter!]
  technicalDetails: [SupPartExtrasTechnicalDetail!] @deprecated(reason: "Use `parameters`.")
}

"Nexar supply part data for internal use only."
type SupPartExtrasParameter {
  name: String!
  unit: String
  value: [String!]
}

"Nexar supply part data for internal use only."
type SupPartExtrasTechnicalDetail {
  name: String!
  value: String!
}

union DesUnionPayload = DesComponent | DesErrorPayload

union SupUnionPayload = SupErrorPayload | SupPartExtras

input BooleanOperationFilterInput {
  eq: Boolean
  neq: Boolean
}

input DateTimeOperationFilterInput {
  eq: DateTime
  neq: DateTime
  in: [DateTime]
  nin: [DateTime]
  gt: DateTime
  ngt: DateTime
  gte: DateTime
  ngte: DateTime
  lt: DateTime
  nlt: DateTime
  lte: DateTime
  nlte: DateTime
}

"Input to add component part choices."
input DesAddComponentPartChoicesInput {
  "Component identifier."
  componentId: ID!
  "Manufacturer part choices to add."
  manufacturerParts: [DesPartChoiceInput!]!
  "Use when Altium Designer version 23 option 'Part Choices Revision control' is checked."
  withRevisionControl: Boolean
}

"Input for adding a footprint to a component."
input DesAddFootprintToComponentInput {
  "The component identifier."
  componentId: ID!
  "The identifier of the footprint to add to the component."
  footprintId: ID!
  "The index that the footprint should be added to the component at. If set as 0, it is set as the first and default footprint for the component. If omitted or set as `null`, it is set as the last listed footprint."
  addAtIndex: Int
}

"Input for adding users to a group."
input DesAddUsersToGroupInput {
  "The group node ID."
  id: ID!
  "Workspace user identifiers."
  userIds: [String!]!
}

"Input for CAD bending line."
input DesCadBendingLineInput {
  "CAD bending line start point."
  startPoint: DesCadBoardPointInput
  "CAD bending line end point."
  endPoint: DesCadBoardPointInput
  "CAD bending line fold index required to define the sequence that the bends are folded."
  foldIndex: Int
  "CAD bending line radius."
  radius: Int
  "CAD bending line angle."
  angle: Float
  "Regions that are affected by the CAD bending line."
  affectedRegions: [String!]
}

"Input for CAD Board 3D Body Model Data."
input DesCadBoard3DBodyModelDataInput {
  "File path for model."
  modelFilePath: String
  "File hash for model."
  modelFileHash: String
  "Unique ID for model on server."
  modelIdOnServer: String
  "Model display name."
  modelDisplayName: String
  "Local test file name."
  localTestFileName: String
  "Model file extension."
  modelFileExtension: String
  "Model net name."
  modelNetName: String
  "Model part name."
  modelPartName: String
  "True if ECAD provides the raw 3D model."
  isEcadProvidesRaw3DModel: Boolean
  "Model color."
  color: Long
  "Model opacity."
  opacity: Float
}

"Input for CAD board area."
input DesCadBoardAreaInput {
  "CAD board area designator."
  designator: String
  "CAD board area rotation."
  rotation: Float
  "CAD board area location."
  location: DesCadBoardPointInput
  "CAD board area unique ID."
  uniqueId: String
  "CAD board area comment."
  comment: String
  "Whether the CAD board area restricts a via."
  restrictsVia: Boolean
  "Whether the CAD board area restricts a track."
  restrictsTrack: Boolean
  "Whether the CAD board area restricts copper."
  restrictsCopper: Boolean
  "Whether the CAD board area restricts a SMD pad."
  restrictsSMDPad: Boolean
  "Whether the CAD board area restricts TH pad."
  restrictsTHPad: Boolean
  "CAD board area placement."
  placement: DesCadBoardComponentPlacement
  "JSON serialized *GeometricShape*."
  shapeJson: String
}

"Input for CAD board component."
input DesCadBoardComponentInput {
  "CAD board component designator."
  designator: String
  "CAD board component rotation."
  rotation: Float
  "CAD board component location."
  location: DesCadBoardPointInput
  "CAD board component unique identifier."
  id: String
  "CAD board component variant name."
  variantName: String
  "CAD board component placement."
  placement: DesCadBoardComponentPlacement
  "Whether the CAD board component is locked or not."
  isLocked: Boolean
  "Whether the CAD board component is a free 3D body or not."
  isFree3DBody: Boolean
  "CAD board component board region name."
  boardRegionName: String
  "CAD board component deepening value."
  deepening: Int
  "Whether MCAD uses its own 3D body for CAD board component."
  isMcadUsesOwn3DBody: Boolean
  "CAD board component free 3D body rotation (X direction)."
  free3DBodyRotationX: Float
  "CAD board component free 3D body rotation (Y direction)."
  free3DBodyRotationY: Float
  "CAD board component free 3D body rotation (Z direction)."
  free3DBodyRotationZ: Float
  "CAD board component free 3D body standoff height."
  free3DBodyStandoffHeight: Int
  "In case component contains single 3D body, the body's position relative to the component's origin point is stored here."
  modelInComponentTransform: DesCadBodyTransformationInput
  "In case the component contains a single 3D body AND no conversion was performed when exporting to a 3D model, the 3D model's position relative to board is stored here."
  innerBodyRelativeToBoardTransform: DesCadBodyTransformationInput
}

"Input for CAD board component type."
input DesCadBoardComponentTypeInput {
  "Identifier for CAD board component type."
  id: String
  "Internal unique identifier for CAD board component type."
  internalId: String
  "GUID for CAD board component type item."
  itemGuid: String
  "GUID for CAD board component type revision."
  revisionGuid: String
  "Identifier for company component."
  companyComponentId: String
  "Library reference for CAD board component type."
  libraryReference: String
  "Whether the CAD board component type is from local PCB library or not."
  isFromLocalPcbLibrary: Boolean
  "DMS component name for CAD board component type."
  dmsComponentName: String
  "Body shape for CAD board component type."
  bodyShape: DesCadComponentBodyShapeInput
  "Properties for CAD board component type."
  properties: [DesCadPropertyInput!]
  "Components for CAD board component type."
  components: [DesCadBoardComponentInput!]
}

"Input for CAD board copper layout."
input DesCadBoardCopperLayerInput {
  "CAD board copper layout name."
  name: String
  "CAD board copper layout platform layer identifier."
  platformLayerId: Int
  "CAD board copper layout thickness."
  thickness: Int
  "Whether CAD board copper layout is a pad and via barrels special layer."
  isPadAndViaBarrelsSpecialLayer: Boolean
  "CAD board copper layout models."
  models: [DesCadBoard3DBodyModelDataInput!]
}

"Input for CAD board copper region."
input DesCadBoardCopperRegionInput {
  "CAD board copper region layer name."
  layerName: String
  "JSON serialized array of *GeometricShape*."
  outlineShapesJson: String
  "JSON serialized array of *GeometricShape*."
  holeShapesJson: String
}

"Input for CAD board cutout."
input DesCadBoardCutoutInput {
  "CAD board cutout designator."
  designator: String
  "CAD board cutout rotation."
  rotation: Float
  "CAD board cutout location."
  location: DesCadBoardPointInput
  "Unique identifier for CAD board cutout."
  uniqueId: String
  "CAD board cutout original designator."
  originalDesignator: String
  "CAD board cutout associated component designator."
  associatedComponentDesignator: String
  "JSON serialized *GeometricShape*."
  shapeJson: String
}

"Input for CAD board hole."
input DesCadBoardHoleInput {
  "CAD board hole designator."
  designator: String
  "CAD board hole rotation."
  rotation: Float
  "CAD board hole location."
  location: DesCadBoardPointInput
  "Unique identifier for CAD board hole."
  uniqueId: String
  "CAD board hole original designator."
  originalDesignator: String
  "CAD board hole associated component designator."
  associatedComponentDesignator: String
  "CAD board hole type."
  holeType: DesCadHoleType
  "CAD board hole diameter."
  diameter: Int
  "CAD board hole counter size."
  counterSize: Int
  "CAD board hole counter depth."
  counterDepth: Int
  "CAD board counter angle."
  counterAngle: Float
  "CAD board hole counter type."
  counterType: DesCadCounterType
  "Whether the CAD board hole is plated or not."
  isPlated: Boolean
  "CAD board hole size."
  size: DesCadBoardPointInput
}

"Input for CAD board layer."
input DesCadBoardLayerInput {
  "CAD board layer name."
  name: String
  "CAD board layer platform layer identifier."
  platformLayerId: Int
  "CAD board layer thickness."
  thickness: Int
  "CAD board layer type."
  layerType: DesCadBoardLayerType
  "CAD board layer position."
  layerPosition: DesCadBoardLayerPosition
  "CAD board layer category."
  layerCategory: DesCadBoardLayerCategory
  "CAD board layer physical category."
  layerPhysicalCategory: DesCadBoardLayerPhysicalCategory
  "CAD board layer component placement."
  layerComponentPlacement: DesCadBoardLayerComponentPlacement
  "CAD board layer dielectric type."
  layerDielectricType: DesCadBoardLayerDielectricType
}

"Input for CAD board point."
input DesCadBoardPointInput {
  "CAD board coordinate (X)."
  x: Int!
  "CAD board coordinate (Y)."
  y: Int!
  "CAD board coordinate (Z)."
  z: Int!
}

"Input for CAD board region."
input DesCadBoardRegionInput {
  "CAD board region name."
  name: String
  "CAD board region bottom layer Z value."
  regionLayerZBottom: Int
  "CAD board region top layer Z value."
  regionLayerZTop: Int
  "Whether CAD board region is flex."
  isFlex: Boolean
  "Whether CAD board region is locked 3D."
  isLocked3D: Boolean
  "CAD board region color."
  color: Long
  "CAD board region internal point."
  internalPoint: DesCadBoardPointInput
  "JSON serialized *ComplexShape*."
  shapeJson: String
  "CAD board region layers."
  layers: [DesCadBoardLayerInput!]
}

"CAD board track input."
input DesCadBoardTrackInput {
  "CAD board track net name."
  netName: String
  "CAD board track layer name."
  layerName: String
  "CAD board track width."
  width: Int
  "CAD board track points."
  points: [DesCadBoardPointInput!]
}

"Input for CAD board variant."
input DesCadBoardVariantInput {
  "Unique identifier for CAD board variant."
  uniqueId: String
  "CAD board variant name."
  name: String
  "CAD board variant description."
  description: String
  "CAD board variant properties."
  properties: [DesCadPropertyInput!]
  "CAD board variant variations."
  variations: [DesCadComponentVariationInput!]
}

"Input for CAD board variants."
input DesCadBoardVariantsInput {
  "Component type variant library for CAD board variants."
  componentTypeVariantLibrary: [DesCadBoardComponentTypeInput!]
  "Variants for CAD board variants."
  variants: [DesCadBoardVariantInput!]
}

"Input for CAD board via."
input DesCadBoardViaInput {
  "Start layer name for CAD board via."
  startLayerName: String
  "End layer name for CAD board via."
  endLayerName: String
  "CAD board via copper diameter."
  copperDiameter: Int
  "CAD board via hole diameter."
  holeDiameter: Int
  "CAD board via location."
  location: DesCadBoardPointInput
}

"Input for CAD body transformation."
input DesCadBodyTransformationInput {
  "CAD body translation in X direction."
  translationX: Float!
  "CAD body translation in Y direction."
  translationY: Float!
  "CAD body translation in Z direction."
  translationZ: Float!
  "CAD body rotation in X direction."
  rotationX: Float!
  "CAD body rotation in Y direction."
  rotationY: Float!
  "CAD body rotation in Z direction."
  rotationZ: Float!
  "CAD body scale in X direction."
  scaleX: Float!
  "CAD body scale in Y direction."
  scaleY: Float!
  "CAD body scale in Z direction."
  scaleZ: Float!
}

"Input for CAD component body shape."
input DesCadComponentBodyShapeInput {
  "Height of CAD component body shape."
  height: Int
  "Whether CAD component body shape is hidden or not."
  isHidden: Boolean
  "Whether CAD component body shape is bodyless on ECAD."
  isBodylessOnEcad: Boolean
  "JSON serialized *GeometricShape*."
  shapeJson: String
  "Model data for CAD component body shape."
  modelData: DesCadBoard3DBodyModelDataInput
}

"Input for CAD component variation."
input DesCadComponentVariationInput {
  "CAD component variation designator."
  designator: String
  "CAD component variation rotation."
  rotation: Float
  "CAD component variant kind."
  variantKind: DesCadComponentVariationKind
  "CAD component variation component type identifier."
  componentTypeId: String
  "CAD component variation placement."
  placement: DesCadBoardComponentPlacement
  "CAD component variation location."
  location: DesCadBoardPointInput
  "In case the component variation contains a single 3D body, the body's position relative to the component's origin point is stored here."
  modelInComponentTransform: DesCadBodyTransformationInput
}

"Input for CAD design."
input DesCadDesignInput {
  "CAD design board thickness."
  boardThickness: Int
  "CAD design workflow state."
  workflowState: DesCadWorkflowState
  "CAD design file name."
  designFileName: String
  "CAD design variant identifier."
  designVariantId: String
  "CAD design variant name."
  designVariantName: String
  "CAD design export mode."
  layersExportMode: DesCadLayersExportMode
  "Whether CAD design has hatched copper polygons or not."
  hasHatchedCopperPolygons: Boolean
  "CAD design board color."
  boardColor: Long
  "CAD design board core color."
  boardCoreColor: Long
  "CAD design board core opacity."
  boardCoreOpacity: Float
  "CAD design minimal height of components shown."
  minimalHeightComponentsShown: Int
  "Whether CAD design is a RF20 design or not."
  isRF20Design: Boolean
  "CAD design copper export features."
  copperExportFeatures: [DesCadBoardCopperExportFeature!]
  "CAD design collaboration flags."
  collaborationFlags: [DesCadBoardCollaborationFlag!]
  "CAD design board origin."
  boardOrigin: DesCadBoardPointInput
  "CAD design board offset MCAD to ECAD origin."
  boardOffsetMcadToEcadOrigin: DesCadBoardPointInput
  "CAD design coordinate system translation."
  coordinateSystemTranslation: DesCadBoardPointInput
  "CAD design properties."
  properties: [DesCadPropertyInput!]
  "CAD design component types."
  componentTypes: [DesCadBoardComponentTypeInput!]
  "CAD design holes."
  holes: [DesCadBoardHoleInput!]
  "CAD design cutouts."
  cutouts: [DesCadBoardCutoutInput!]
  "CAD design copper layers."
  copperLayers: [DesCadBoardCopperLayerInput!]
  "CAD design copper regions."
  copperRegions: [DesCadBoardCopperRegionInput!]
  "JSON serialized *ComplexShape*."
  boardOutlineJson: String
  "CAD design board split lines."
  boardSplitLines: [DesCadSplitLineInput!]
  "CAD design board regions."
  boardRegions: [DesCadBoardRegionInput!]
  "CAD design board bending lines."
  boardBendingLines: [DesCadBendingLineInput!]
  "CAD design board areas."
  boardAreas: [DesCadBoardAreaInput!]
  "CAD design board layers."
  boardLayers: [DesCadBoardLayerInput!]
  "CAD design tracks."
  tracks: [DesCadBoardTrackInput!]
  "CAD design vias."
  vias: [DesCadBoardViaInput!]
  "CAD design variants."
  variants: DesCadBoardVariantsInput
  "CAD design messages."
  messages: [String!]
}

"Input for CAD property."
input DesCadPropertyInput {
  "CAD property name."
  name: String!
  "CAD property value."
  value: String
}

"Input for CAD split line."
input DesCadSplitLineInput {
  "Start point for CAD split line."
  startPoint: DesCadBoardPointInput
  "End point for CAD split line."
  endPoint: DesCadBoardPointInput
  "Left region name for CAD split line."
  leftRegionName: String
  "Right region name for CAD split line."
  rightRegionName: String
  "JSON serialized *ComplexShape*."
  shapeJson: String
}

"Input for collaboration simulation file."
input DesCollaborationSimulationFileInput {
  "Collaboration simulation file identifier."
  fileId: String!
  "Collaboration simulation file type."
  fileType: String!
  "Collaboration simulation file name."
  fileName: String!
}

"Input for object color."
input DesColorInput {
  "The color input in hex format, e.g. '#AABBCC'."
  hexString: String
  "The color input in numerical format, e.g. 'RGB(255, 255, 0)'."
  rgbString: String
}

"A component contains the parametric details of a PCB part."
input DesComponentFilterInput {
  "The library label for this component."
  name: DesComponentStringOperationFilterInput
  "The additional information for this component."
  comment: DesComponentStringOperationFilterInput
  "The summary of function or other performance details for this component."
  description: DesComponentStringOperationFilterInput
}

"Input for the parametric details of a component."
input DesComponentItemParameterInput {
  "Component item parameter name."
  name: String!
  "Component item parameter value."
  value: String!
}

input DesComponentStringOperationFilterInput {
  eq: String
}

input DesComponentUpgradeFilterInput {
  "Filter by component name (HRID)."
  name: DesStringUpgradeOperationFilterInput
  "Filter by the component's description."
  description: DesStringUpgradeOperationFilterInput
  "Filter by the component's comment field."
  comment: DesStringUpgradeOperationFilterInput
  "Filter by the name of the component's lifecycle state (e.g., \"Validated\")."
  lifeCycleStateName: DesLifecycleStateUpgradeOperationFilterInput
}

"Input for comment creation."
input DesCreateCommentInput {
  "Comment entity identifier."
  entityId: ID!
  "Comment thread identifier."
  commentThreadId: String!
  "Comment text."
  text: String!
}

"Input for comment thread creation."
input DesCreateCommentThreadInput {
  "Comment thread entity identifier."
  entityId: ID!
  "Comment thread document identifier."
  documentId: String!
  "Comment thread document name."
  documentName: String
  "Comment thread document type."
  documentType: DesDocumentType!
  "Comment thread text."
  text: String!
  "Comment thread comment context type."
  commentContextType: DesCommentContextType!
  "Comment thread item as design item identifier."
  itemAsDesignItemId: ID @deprecated(reason: "Use `ItemAsDesignItemSchUniqueId` or `ItemAsDesignItemPcbUniqueId` instead.")
  "Comment thread item as design item schematic identifier."
  itemAsDesignItemSchUniqueId: String
  "Comment thread item as design item PCB identifier."
  itemAsDesignItemPcbUniqueId: String
  "Comment thread item as internal object identifier."
  itemAsInternalObjectId: String
  "Comment thread area."
  area: DesRectangleInput
  "Comment thread release identifier."
  releaseId: String
}

"Input for folder creation."
input DesCreateFolderInput {
  "URL of the workspace into which the folder has to be created."
  workspaceUrl: String
  "Folder name."
  name: String!
  "Folder description."
  description: String
  "Folder type."
  folderType: DesFolderType!
  "Identifier of the parent folder. If both `parentId` and `parentFolderId` are omitted or set to `null`, the folder will be placed under the library root."
  parentId: ID @deprecated(reason: "Use `parentFolderId` instead.")
  "Reference identifier of the parent folder. If both `parentId` and `parentFolderId` are omitted or set to `null`, the folder will be placed under the library root."
  parentFolderId: String
  "Naming scheme for the folder items."
  itemNamingSchemeTemplate: String
  "Folder permissions (non recursive)."
  permissions: [DesUpdateFolderPermissionInput!]
}

"Input for creating a footprint file."
input DesCreateFootprintFileInput {
  "Uploaded file identifier (typically a *PcbLib* file)."
  fileId: String!
  "Relative path of the source file (typically *Released\/filename.PcbLib*)."
  relativePath: String!
}

"Input for creating a footprint."
input DesCreateFootprintInput {
  "The workspace URL."
  workspaceUrl: String
  "The destination folder identifier."
  folderId: ID!
  "The footprint name. Use null to be generated, provided that the destination folder defines an item naming scheme."
  name: String
  "The footprint files."
  files: [DesCreateFootprintFileInput!]!
  "The footprint revision naming scheme identifier."
  revisionNamingSchemeId: ID
  "The footprint life cycle definition identifier."
  lifeCycleDefinitionId: ID
  "Comment for footprint revision."
  comment: String
  "Description for footprint revision."
  description: String
  "Parameters for footprint revision."
  parameters: [DesRevisionParameterInput!]
}

"Input for creating a life cycle definition."
input DesCreateLifeCycleDefinitionInput {
  "Defines which workspace the life cycle definition should be created on."
  workspaceUrl: String
  lifeCycleDefinition: DesLifeCycleDefinitionInput!
}

"Input for manufacture package creation."
input DesCreateManufacturePackageInput {
  "The identifier of the project to create a manufacture package from."
  projectId: ID!
  "The Git commit which determines the version of the project to use. If not provided, the latest version is used."
  vcsRevisionId: String
  "The name for the package."
  name: String!
  "A description for the package."
  description: String
  "The email addresses of the manufacturers to share the package with."
  shareWith: [String!]!
  "The project variant to use when creating the package. If not provided, the default variant is used."
  variantName: String
  "A webhook URL that will receive a POST request when the manufacture package has been created and shared."
  callbackUrl: String
}

"Input for project export job creation."
input DesCreateProjectExportJobInput {
  "Project identifier."
  projectId: ID!
  "The Git commit which determines the version of the project to use. If not provided, the latest version is used."
  vcsRevisionId: String
  "The project variant to use when creating the package. If not provided, the default variant is used."
  variantName: String
  "Tells to export any data specified by the input."
  exportAny: DesProjectExportAnyInput
  "Tells to export *Gerber* and specifies the options."
  exportGerber: DesProjectExportGerberInput
  "Tells to export *GerberX2* and specifies the options."
  exportGerberX2: DesProjectExportGerberX2Input
  "Tells to export *IDF* and specifies the options."
  exportIdf: DesProjectExportIdfInput
  "Tells to export *NCDrill* and specifies the options."
  exportNCDrill: DesProjectExportNCDrillInput
}

"Input for project task creation."
input DesCreateProjectTaskInput {
  "Project identifier."
  projectId: ID!
  "The new task data."
  task: DesCreateTaskInput!
}

"Input for revision naming scheme creation."
input DesCreateRevisionNamingSchemeInput {
  "The workspace URL that the revision naming scheme should be created on."
  workspaceUrl: String
  "The name of this revision naming scheme."
  name: String!
  "If true, the revision naming scheme is only applicable to objects of the content types specified by `contentTypes`."
  isControlledPerContentType: Boolean
  "If `isControlledPerContentType` is true, the list of content types for which this revision naming scheme is applicable."
  contentTypes: [DesContentTypeKind!]
  "The list of numbering levels for this revision naming scheme. Maximum of 3 levels."
  levels: [DesCreateRevisionNamingSchemeLevelInput!]!
  "The separator used between item ID and revision ID. Allowed characters are: ',', '.', '-', '_'."
  itemRevisionSeparator: String!
}

"Input for revision naming scheme level creation."
input DesCreateRevisionNamingSchemeLevelInput {
  "The name of this revision naming level. In Altium Designer it is known as 'Caption'."
  name: String!
  "The minimum character length allowed for this revision naming scheme level."
  minimumWidth: Int!
  "The separator prefix character for this revision naming scheme level. Allowed characters are: ',', '.', '-', '_'."
  levelSeparator: String!
  "The naming policy for this revision naming scheme level."
  revisionNamingPolicy: DesRevisionNamingPolicy!
}

"Input for creating a symbol file."
input DesCreateSymbolFileInput {
  "Uploaded file identifier (typically a *SchLib* file)."
  fileId: String!
  "Relative path of the source file (typically *Released\/filename.SchLib*)."
  relativePath: String!
}

"Input for creating a symbol."
input DesCreateSymbolInput {
  "The workspace URL."
  workspaceUrl: String
  "The destination folder identifier."
  folderId: ID!
  "The symbol name. Use null to be generated, provided that the destination folder defines an item naming scheme."
  name: String
  "The symbol files."
  files: [DesCreateSymbolFileInput!]!
  "The symbol revision naming scheme identifier."
  revisionNamingSchemeId: ID
  "The symbol life cycle definition identifier."
  lifeCycleDefinitionId: ID
}

"Input for task comment creation."
input DesCreateTaskCommentInput {
  "The task node ID."
  taskId: ID!
  "The comment text."
  text: String!
}

"Input for task creation."
input DesCreateTaskInput {
  "New task name."
  name: String!
  "New task description."
  description: String!
  "Optional task priority."
  priority: DesTaskPriority
  "Optional task status."
  status: DesTaskStatus
}

"Input for user group creation."
input DesCreateUserGroupInput {
  "URL for workspace in which the user group is to be created."
  workspaceUrl: String
  "User group name."
  name: String!
}

"Input for user creation."
input DesCreateUserInput {
  "URL for the workspace to add the new user into."
  workspaceUrl: String
  "New user username."
  userName: String!
  "New user password."
  password: String!
  "New user first name."
  firstName: String!
  "New user last name."
  lastName: String!
  "New user email."
  email: String!
}

"Input for workspace task creation."
input DesCreateWorkspaceTaskInput {
  "The workspace URL."
  workspaceUrl: String
  "The new task data."
  task: DesCreateTaskInput!
}

"A component datasheet."
input DesDatasheetFilterInput {
  and: [DesDatasheetFilterInput!]
  or: [DesDatasheetFilterInput!]
  "ECAD entity name."
  name: StringOperationFilterInput
  "ECAD entity description."
  description: StringOperationFilterInput
  "ECAD entity comment."
  comment: StringOperationFilterInput
}

"Input for deleting a comment."
input DesDeleteCommentInput {
  "Entity identifier."
  entityId: ID!
  "Comment thread identifier."
  commentThreadId: String!
  "Comment identifier."
  commentId: String!
}

"Input for deleting a comment thread."
input DesDeleteCommentThreadInput {
  "Entity identifier."
  entityId: ID!
  "Comment thread identifier."
  commentThreadId: String!
}

"Input for deleting a folder."
input DesDeleteFolderInput {
  "ID of the folder to delete."
  id: ID @deprecated(reason: "Use `workspaceUrl` and `folderId` instead.")
  "Reference identifier of the folder to delete."
  folderId: String
  "URL of the workspace in which the folder exists."
  workspaceUrl: String
}

"Input for deleting a life cycle definition."
input DesDeleteLifeCycleDefinitionInput {
  "Defines which life cycle definition should be deleted."
  id: ID!
}

"Input for deleting a revision naming scheme."
input DesDeleteRevisionNamingSchemeInput {
  "The revision naming scheme to be deleted."
  id: ID!
}

"Input for deleting a task comment."
input DesDeleteTaskCommentInput {
  "The task node ID."
  taskId: ID!
  "The comment ID."
  commentId: String!
}

"Input for deleting a task."
input DesDeleteTaskInput {
  "The task node ID."
  taskId: ID!
}

"Input for deleting a user group."
input DesDeleteUserGroupInput {
  "The group node ID."
  id: ID!
}

"Input for deleting a user."
input DesDeleteUserInput {
  "URL for the workspace to delete the user from."
  workspaceUrl: String
  "Workspace user identifier."
  userId: String!
}

"A design item is a specific instance of a part used in the design."
input DesDesignItemFilterInput {
  and: [DesDesignItemFilterInput!]
  or: [DesDesignItemFilterInput!]
  "The unique label for this design item."
  designator: StringOperationFilterInput
  "The layer(side) placement for this design item."
  layer: DesLayerFilterInput
  "The list of parameters describing the design item."
  parameters: ListFilterInputTypeOfDesDesignItemParameterFilterInput
}

"A parameter describing the design item."
input DesDesignItemParameterFilterInput {
  and: [DesDesignItemParameterFilterInput!]
  or: [DesDesignItemParameterFilterInput!]
  "Parameter name."
  name: StringOperationFilterInput
  "Parameter value."
  value: StringOperationFilterInput
}

input DesFolderFilterInput {
  "Filters folders by their type. If null, this condition is ignored."
  folderType: DesFolderType
  "Filters folders by the GUID of their parent folder. If null, this condition is ignored."
  parentFolderGuid: String
  "Specifies how multiple conditions should be combined. Use AND to match all conditions, OR to match any condition. If null, AND operator is used."
  matchMode: DesFolderFilterMatchMode
  "Filters folders by their name. If null, this condition is ignored."
  name: String
}

"Provides filter options for a list of footprints."
input DesFootprintFilterInput {
  and: [DesFootprintFilterInput!]
  or: [DesFootprintFilterInput!]
  "Filter by the ECAD entity name."
  name: StringOperationFilterInput
  "Filter by the ECAD entity description."
  description: StringOperationFilterInput
  "Filter by the ECAD entity comment."
  comment: StringOperationFilterInput
}

"Input for launching a workflow."
input DesLaunchWorkflowInput {
  "URL of workspace."
  workspaceUrl: String
  "Identifier for workflow definition."
  workflowDefinitionId: String!
  "Name of workflow definition."
  name: String
  "The string variables."
  variables: [DesWorkflowVariableInput!]!
  "The attachment variables."
  attachments: [DesWorkflowAttachmentVariableInput!]
}

"Information about a specific layer in the PCB."
input DesLayerFilterInput {
  and: [DesLayerFilterInput!]
  or: [DesLayerFilterInput!]
  "Layer name."
  name: StringOperationFilterInput
}

"Input for life cycle definition."
input DesLifeCycleDefinitionInput {
  "Name of life cycle definition."
  name: String!
  "Returns `true` if a revision scheme is assigned to the life cycle definition."
  isRevisionSchemeAssigned: Boolean!
  "Returns `true` if the life cycle definition is controlled per content type."
  isControlledPerContentType: Boolean
  "Content types of life cycle definition."
  contentTypes: [DesContentTypeKind!]
  "Stages of life cycle definition."
  stages: [DesLifeCycleStageInput!]
  "State transitions of life cycle definition."
  stateTransitions: [DesLifeCycleStateTransitionInput!]
}

"Input for life cycle stage."
input DesLifeCycleStageInput {
  "Name of life cycle stage."
  name: String!
  "Index of life cycle stage."
  stageIndex: Int!
  "States of life cycle stage."
  states: [DesLifeCycleStateInput!]!
}

"Input for life cycle state."
input DesLifeCycleStateInput {
  "Name of life cycle state."
  name: String!
  "Description of life cycle state."
  description: String!
  "Returns `true` if this is the initial state."
  isInitialState: Boolean
  "State index of life cycle state."
  stateIndex: Int!
  "Background color of life cycle state."
  backgroundColor: DesColorInput
  "Foreground color of life cycle state."
  foregroundColor: DesColorInput
}

"Input for the life cycle state transition approval group."
input DesLifeCycleStateTransitionApprovalGroupInput {
  "The name of this life cycle state transition approval group."
  name: String!
  "The controllers that can provide an approval for this life cycle state transition approval group."
  controllers: [DesLifeCycleStateTransitionControllerInput!]!
}

"Input for life cycle state transition controller."
input DesLifeCycleStateTransitionControllerInput {
  "Scope of the transition controller."
  scope: DesPermissionScope!
  "Workspace user identifier."
  userId: String
  "Group identifier."
  groupId: ID
}

"Input for life cycle state transition."
input DesLifeCycleStateTransitionInput {
  "Name of life cycle state transition."
  name: String!
  "Menu text format for life cycle state transition."
  menuTextFormat: String!
  "The name of the life cycle state before the transition."
  stateBefore: String!
  "The name of the life cycle state after the transition."
  stateAfter: String!
  "Controllers of this life cycle definition transition. If controllers and approvals are omitted, the controllers will default to ANYONE."
  controllers: [DesLifeCycleStateTransitionControllerInput!]
  "Approval groups for this life cycle definition transition. Mutually exclusive with controllers, if approvals are set, controllers must be omitted."
  approvals: [DesLifeCycleStateTransitionApprovalGroupInput!]
}

input DesLifecycleStateUpgradeOperationFilterInput {
  "Equals."
  eq: String
  "Not equals."
  neq: String
  "Is one of the given strings."
  in: [String!]
  "Is not one of the given strings."
  notIn: [String!]
}

"Input for moving a folder."
input DesMoveFolderInput {
  "ID of the folder to move."
  id: ID @deprecated(reason: "Use `workspaceUrl` and `folderId` instead.")
  "Identifier of the new parent folder. If both `parentId` and `parentFolderId` are omitted or set to `null`, the folder will be placed under the library root."
  parentId: ID @deprecated(reason: "Use `workspaceUrl` and `parentFolderId` instead.")
  "URL of the workspace in which the folder and parent folder (if used) exist."
  workspaceUrl: String
  "Reference identifier for the folder to update."
  folderId: String
  "Reference identifier of the parent folder. If both `parentId` and `parentFolderId` are omitted or set to `null`, the folder will be placed under the library root."
  parentFolderId: String
}

"Input for subscribing to comment update notifications."
input DesOnCommentUpdatedInput {
  "Workspace URL."
  workspaceUrl: String
  "Access token for authorization."
  token: String!
}

"Input for part choice."
input DesPartChoiceInput {
  "Name of company for part choice."
  companyName: String!
  "Part number for part choice."
  partNumber: String!
}

"2D positional information in mm and mils."
input DesPosition2DInput {
  "Positional coordinate (X)."
  x: Int!
  "Positional coordinate (Y)."
  y: Int!
}

"Input for exporting project."
input DesProjectExportAnyInput {
  "The content of Altium Designer *OutJob* file."
  outJobContent: String!
  "A suggested result file name. Default: *Export.zip*."
  fileName: String
}

"Input for exporting project Gerber file."
input DesProjectExportGerberInput {
  "A suggested result file name. Default: *Gerber.zip*."
  fileName: String
}

"Input for exporting project Gerber X2 file."
input DesProjectExportGerberX2Input {
  "A suggested result file name. Default: *GerberX2.zip*."
  fileName: String
}

"Input for exporting project IDF file."
input DesProjectExportIdfInput {
  "A suggested result file name. Default: *IDF.zip*."
  fileName: String
}

"Input for exporting project NC Drill file."
input DesProjectExportNCDrillInput {
  "A suggested result file name. Default: *NCDrill.zip*."
  fileName: String
}

"A project manages all development stages of the PCB\/PCA product lifecycle."
input DesProjectFilterInput {
  and: [DesProjectFilterInput!]
  or: [DesProjectFilterInput!]
  "The Altium 365 web address."
  url: StringOperationFilterInput
  "The Altium 365 workspace URL."
  workspaceUrl: StringOperationFilterInput
  "The reference identifier for this project."
  projectId: StringOperationFilterInput
  "The assigned name for this project."
  name: StringOperationFilterInput
  "The summary of this project content or purpose."
  description: StringOperationFilterInput
  "The project type."
  projectType: DesProjectTypeOperationFilterInput
  "The `DateTime` when this project was created."
  createdAt: DateTimeOperationFilterInput
  "The `DateTime` when this project was last modified."
  updatedAt: DateTimeOperationFilterInput
}

"Input for the parametric details of a project."
input DesProjectParameterInput {
  "Project parameter name."
  name: String!
  "Project parameter value."
  value: String!
}

input DesProjectTypeOperationFilterInput {
  eq: DesProjectType
  neq: DesProjectType
  in: [DesProjectType!]
  nin: [DesProjectType!]
}

"`desProjects` extra arguments."
input DesProjectsInput {
  "Tells to get projects with layers."
  hasLayers: Boolean
}

input DesProjectsRequirementsBlockFilterInput {
  "Requirements block IDs."
  blockIds: [String!]!
}

"Rectangle positional information."
input DesRectangleInput {
  "Rectangle corner point 1."
  pos1: DesPosition2DInput!
  "Rectangle corner point 2."
  pos2: DesPosition2DInput!
}

"Input for releasing component datasheet."
input DesReleaseComponentDatasheetInput {
  "Datasheet identifier for adding an existing datasheet to the release. Either 'id' or 'file' must be provided."
  id: ID
  "The datasheet name for the 'file'. Use null to be generated."
  itemName: String
  "The datasheet file for adding a new datasheet to the release. Either 'id' or 'file' must be provided."
  file: DesReleaseComponentFileInput
  "The datasheet revision naming scheme identifier. Required when 'file' is provided."
  revisionNamingSchemeNodeId: ID
  "The datasheet life cycle definition identifier. Required when 'file' is provided."
  lifeCycleDefinitionNodeId: ID
}

"Input for releasing component file."
input DesReleaseComponentFileInput {
  "Uploaded file identifier."
  fileId: String!
  "Relative path of the source file."
  relativePath: String!
}

"Input for adding existing footprints to the release."
input DesReleaseComponentFootprintInput {
  "Footprint identifier."
  id: ID!
}

"Input for releasing component."
input DesReleaseComponentInput {
  "Workspace URL for releasing a component."
  workspaceUrl: String
  "Destination parent folder identifier for releasing a component. If omitted or empty, `componentReleaseFolder` is required."
  componentParentFolderId: ID
  "New child folder name for releasing a component. If omitted or empty, `componentParentFolderId` is required."
  componentReleaseFolder: String
  "When `componentReleaseFolder` is set, tells to use existing folder if any, otherwise create a new folder."
  useExistingComponentReleaseFolder: Boolean
  "Name of component item."
  componentItemName: String!
  "**DEPRECATED** Use `componentRevisionNamingSchemeNodeId` instead with a value from `DesRevisionNamingScheme.id`."
  componentRevisionNamingSchemeId: String
  "Revision naming scheme identifier for component."
  componentRevisionNamingSchemeNodeId: ID
  "**DEPRECATED** Use `componentLifeCycleDefinitionNodeId` instead with a value from `DesLifeCycleDefinition.id`."
  componentLifeCycleDefinitionId: String
  "Life cycle definition identifier for component."
  componentLifeCycleDefinitionNodeId: ID
  "Comment for component."
  componentComment: String
  "Description for component."
  componentDescription: String
  "Parameters for component."
  parameters: [DesRevisionParameterInput!]!
  "The symbol folder path, existing or to be created. Required when `symbolFiles` are provided."
  symbolReleaseFolder: String
  "The symbol name. Use null to be generated."
  symbolItemName: String
  "The symbol files. Either `symbolFiles` or `symbol` must be provided."
  symbolFiles: [DesReleaseComponentFileInput!]
  "Existing symbol to include. Either `symbolFiles` or `symbol` must be provided."
  symbol: DesReleaseComponentSymbolInput
  "**DEPRECATED** Use `symbolRevisionNamingSchemeNodeId` instead with a value from `DesRevisionNamingScheme.id`."
  symbolRevisionNamingSchemeId: String
  "The symbol revision naming scheme identifier."
  symbolRevisionNamingSchemeNodeId: ID
  "**DEPRECATED** Use `symbolLifeCycleDefinitionNodeId` instead with a value from `DesLifeCycleDefinition.id`."
  symbolLifeCycleDefinitionId: String
  "The symbol life cycle definition identifier."
  symbolLifeCycleDefinitionNodeId: ID
  "The footprint folder path, existing or to be created. Required when `footprintFiles` are provided."
  footprintReleaseFolder: String
  "The footprint name. Use null to be generated."
  footprintItemName: String
  "The footprint files. Either `footprintFiles` or `footprints` must be provided."
  footprintFiles: [DesReleaseComponentFileInput!]
  "Existing footprints to include. Either `footprintFiles` or `footprints` must be provided."
  footprints: [DesReleaseComponentFootprintInput!]
  "**DEPRECATED** Use `footprintRevisionNamingSchemeNodeId` instead with a value from `DesRevisionNamingScheme.id`."
  footprintRevisionNamingSchemeId: String
  "The footprint revision naming scheme identifier."
  footprintRevisionNamingSchemeNodeId: ID
  "**DEPRECATED** Use `footprintLifeCycleDefinitionNodeId` instead with a value from `DesLifeCycleDefinition.id`."
  footprintLifeCycleDefinitionId: String
  "The footprint life cycle definition identifier."
  footprintLifeCycleDefinitionNodeId: ID
  "Datasheets for component."
  datasheets: [DesReleaseComponentDatasheetInput!]
  "The datasheet folder path, existing or to be created."
  datasheetReleaseFolder: String
  "Naming scheme template for the datasheet folder."
  datasheetReleaseFolderItemNamingSchemeTemplate: String
}

"Input for adding existing symbols to the release."
input DesReleaseComponentSymbolInput {
  "Symbol identifier."
  id: ID!
}

"Input for releasing a component template."
input DesReleaseComponentTemplateInput {
  "The target workspace URL."
  workspaceUrl: String
  "The target folder path, existing or to be created."
  folder: String!
  "The component template name."
  name: String!
  "The component template content (CMPT format JSON string)."
  contentAsText: String!
  "Optional naming scheme ID."
  revisionNamingSchemeId: String
  "Optional life cycle ID."
  lifeCycleDefinitionId: String
  "Optional comment."
  comment: String
  "Optional description."
  description: String
  "Optional parameters."
  parameters: [DesRevisionParameterInput!]
}

"A release is a published version of a design with additional generated files for manufacturing."
input DesReleaseFilterInput {
  and: [DesReleaseFilterInput!]
  or: [DesReleaseFilterInput!]
  "The `DateTime` when this release was created."
  createdAt: DateTimeOperationFilterInput
  "The summary of this release content or purpose."
  description: StringOperationFilterInput
  "The reference identifier for this release."
  releaseId: StringOperationFilterInput
}

"A variant contains a specific configuration of a base design."
input DesReleaseVariantFilterInput {
  and: [DesReleaseVariantFilterInput!]
  or: [DesReleaseVariantFilterInput!]
  "The descriptive label for this design variant."
  name: StringOperationFilterInput
}

"Input to remove component part choices."
input DesRemoveComponentPartChoicesInput {
  "Component identifier."
  componentId: ID!
  "Manufacturer part choices to remove. Use null to remove all choices."
  manufacturerParts: [DesPartChoiceInput!]
  "Use when Altium Designer version 23 option 'Part Choices Revision control' is checked."
  withRevisionControl: Boolean
}

"Input for removing a footprint from a component."
input DesRemoveFootprintFromComponentInput {
  "The component identifier."
  componentId: ID!
  "The identifier of the footprint to remove from the component."
  footprintId: ID!
}

"Input to remove users from group."
input DesRemoveUsersFromGroupInput {
  "The group node ID."
  id: ID!
  "Workspace user identifiers."
  userIds: [String!]!
}

"Input for revision parameter."
input DesRevisionParameterInput {
  "Revision parameter name."
  name: String!
  "Revision parameter value."
  value: String!
}

"A schematic contains the design parts and logical connections."
input DesSchematicFilterInput {
  and: [DesSchematicFilterInput!]
  or: [DesSchematicFilterInput!]
  "The reference identifier for this schematic."
  documentId: StringOperationFilterInput
  "The document file name."
  documentName: StringOperationFilterInput
}

input DesSetProjectRequirementsBlockInput {
  "Project identifier."
  projectId: ID!
  "Requirements block ID."
  requirementsBlockId: String
}

"Information about a project that is shared with the user."
input DesSharedWithMeProjectInfoFilterInput {
  and: [DesSharedWithMeProjectInfoFilterInput!]
  or: [DesSharedWithMeProjectInfoFilterInput!]
  "The project name."
  name: StringOperationFilterInput
  "The project description."
  description: StringOperationFilterInput
}

input DesStringUpgradeOperationFilterInput {
  "Equals."
  eq: String
  "Not equals."
  neq: String
  "Contains the given string."
  contains: String
  "Starts with the given string."
  startsWith: String
  "Ends with the given string."
  endsWith: String
  "Is one of the given strings."
  in: [String!]
  "Is not one of the given strings."
  notIn: [String!]
}

"A component symbol. These represent the body and the pins on the physical component."
input DesSymbolFilterInput {
  and: [DesSymbolFilterInput!]
  or: [DesSymbolFilterInput!]
  "ECAD entity name."
  name: StringOperationFilterInput
  "ECAD entity description."
  description: StringOperationFilterInput
  "ECAD entity comment."
  comment: StringOperationFilterInput
}

"Input for terminating workflows."
input DesTerminateWorkflowsInput {
  "Workspace URL."
  workspaceUrl: String
  "Workflow identifiers."
  workflowIds: [String!]!
}

"PCB design track information."
input DesTrackFilterInput {
  and: [DesTrackFilterInput!]
  or: [DesTrackFilterInput!]
  "Layer associated with the track."
  layer: DesLayerFilterInput
}

"Input for updating comment."
input DesUpdateCommentInput {
  "Entity identifier for updating a comment."
  entityId: ID!
  "Identifier for comment thread."
  commentThreadId: String!
  "Identifier for comment."
  commentId: String!
  "Comment text."
  text: String!
}

"Input for updating component item parameters."
input DesUpdateComponentItemParametersInput {
  "Component identifier."
  componentId: ID!
  "Tells to replace all existing parameters. By default parameters are added to existing."
  replaceExisting: Boolean
  "Parameters to describe the component item."
  parameters: [DesComponentItemParameterInput!]!
}

"Input to update component life cycle state."
input DesUpdateComponentLifeCycleStateInput {
  "Component identifier."
  componentId: ID!
  "Life cycle transition state identifier."
  lifeCycleStateTransitionId: String!
  "Comment."
  comment: String
}

"Input for updating component revision parameters."
input DesUpdateComponentRevisionParametersInput {
  "Component identifier."
  componentId: ID!
  "Component revision naming scheme identifier."
  componentRevisionNamingSchemeId: String
  "Release note to go alongside update."
  releaseNote: String
  "If set to `true`, all existing parameters are overwritten. By default, parameters are added as new parameters."
  replaceExisting: Boolean
  "Parameters to update."
  parameters: [DesRevisionParameterInput!]!
}

"Input for updating the symbol of a component."
input DesUpdateComponentSymbolInput {
  "The component identifier."
  componentId: ID!
  "The identifier of the symbol to link to the component. If omitted or set to `null`, the symbol will be unlinked from the component."
  symbolId: ID
}

"Input for updating component template."
input DesUpdateComponentTemplateInput {
  "The node ID."
  componentTemplateId: ID!
  "The component template content (CMPT format JSON string)."
  contentAsText: String!
  "Optional comment."
  comment: String
  "Optional description."
  description: String
}

"Input for updating folder."
input DesUpdateFolderInput {
  "ID of the folder to update."
  id: ID @deprecated(reason: "Use `workspaceUrl` and `folderId` instead.")
  "URL of the workspace in which the folder exists."
  workspaceUrl: String
  "Reference identifier for the folder to update."
  folderId: String
  "New name of the folder. Not updated if omitted or set to `null`."
  name: String
  "New description of the folder. Not updated if omitted or set to `null`."
  description: String
  "New folder type. Not updated if omitted or set to `null`."
  folderType: DesFolderType
  "New naming scheme for the folder items. Not updated if omitted or set to `null`."
  itemNamingSchemeTemplate: String
  "New folder permissions (non recursive). Not updated if omitted or set to `null`."
  permissions: [DesUpdateFolderPermissionInput!]
}

"Input for updating folder permission."
input DesUpdateFolderPermissionInput {
  "Allows updating, deleting and creating when set, otherwise only read permissions will be allowed."
  canModify: Boolean!
  "Scope of the permission."
  scope: DesPermissionScope!
  "Workspace user identifier."
  userId: String
  "Group identifier."
  groupId: ID
}

"Input for updating folder permissions."
input DesUpdateFolderPermissionsInput {
  "Folder identifier for updating folder permissions. Soon, `folderId` will be the reference identifier (GUID) instead of node identifier, and should be used along with `workspaceUrl`."
  folderId: ID!
  "URL of the workspace in which the folder exists."
  workspaceUrl: String
  "Tells to replace all existing permissions. By default permissions are added to existing."
  replaceExisting: Boolean
  "Permissions to update."
  permissions: [DesUpdateFolderPermissionInput!]!
}

"Input for updating a footprint."
input DesUpdateFootprintInput {
  "The footprint identifier."
  footprintId: ID!
  "Optional comment."
  comment: String
  "Optional description."
  description: String
  "Optional release note."
  releaseNote: String
}

"Input to update footprint life cycle state."
input DesUpdateFootprintLifeCycleStateInput {
  "Footprint identifier."
  footprintId: ID!
  "Life cycle transition state identifier."
  lifeCycleStateTransitionId: String!
  "Comment."
  comment: String
}

"Input for updating life cycle definition."
input DesUpdateLifeCycleDefinitionInput {
  "Life cycle definition identifier. Defines which life cycle definition should be updated."
  id: ID!
  "Life cycle definition."
  lifeCycleDefinition: DesLifeCycleDefinitionInput!
}

"Input for updating project parameters."
input DesUpdateProjectParametersInput {
  "Project identifier."
  projectId: ID!
  "Replace all existing user-specific project parameters. By default parameters are appended to the existing list."
  replaceExisting: Boolean
  "Parameters to describe the project."
  parameters: [DesProjectParameterInput!]!
}

"Input for updating project permission."
input DesUpdateProjectPermissionInput {
  "User identifier. Workspace user identifier should be used for the scope 'USER', global user identifier should be used for the scope 'GUEST'."
  userId: String
  "Allows updating, deleting and creating when set, otherwise only read permissions will be allowed."
  canModify: Boolean!
  "Scope of the permission."
  scope: DesPermissionScope!
  "Group identifier."
  groupId: ID
}

"Input for updating project permissions."
input DesUpdateProjectPermissionsInput {
  "Project identifier."
  projectId: ID!
  "Tells to replace all existing permissions. By default permissions are added to existing."
  replaceExisting: Boolean
  "Permissions to update."
  permissions: [DesUpdateProjectPermissionInput!]!
}

"Input to update reuse block."
input DesUpdateReuseBlockInput {
  "Reuse block identifier."
  id: ID!
  "Reuse block name."
  name: String
  "Reuse block description."
  description: String
}

"Input for updating revision naming scheme."
input DesUpdateRevisionNamingSchemeInput {
  "The revision naming scheme to be updated."
  id: ID!
  "The name of this revision naming scheme."
  name: String
  "If true, the revision naming scheme is only applied to objects that are controlled by that content type. Otherwise, content types are ignored."
  isControlledPerContentType: Boolean
  "If `isControlledPerContentType` is true, the list of content types for which this revision naming scheme is applicable."
  contentTypes: [DesContentTypeKind!]
  "The list of numbering levels for this revision naming scheme. Maximum of 3 levels."
  levels: [DesUpdateRevisionNamingSchemeLevelInput!]
  "The separator used between item ID and revision ID. Allowed characters are: ',', '.', '-', '_'."
  itemRevisionSeparator: String
}

"Input for updating revision naming scheme level."
input DesUpdateRevisionNamingSchemeLevelInput {
  "The name of this revision naming level. In Altium Designer it is known as 'Caption'."
  name: String
  "The minimum character length allowed for this revision naming scheme level."
  minimumWidth: Int
  "The separator prefix character for this revision naming scheme level. Allowed characters are: ',', '.', '-', '_'."
  levelSeparator: String
  "The naming policy for this revision naming scheme level."
  revisionNamingPolicy: DesRevisionNamingPolicy
}

"Input for updating a setting."
input DesUpdateSettingInput {
  "The workspace URL that the setting should be updated on."
  workspaceUrl: String
  "The name of the setting to be updated."
  name: String!
  "The value that the setting should be replaced with."
  value: String!
}

"Input for updating a symbol."
input DesUpdateSymbolInput {
  "The symbol identifier."
  symbolId: ID!
  "Optional comment."
  comment: String
  "Optional description."
  description: String
  "Optional release note."
  releaseNote: String
}

"Input to update symbol life cycle state."
input DesUpdateSymbolLifeCycleStateInput {
  "Symbol identifier."
  symbolId: ID!
  "Life cycle transition state identifier."
  lifeCycleStateTransitionId: String!
  "Comment."
  comment: String
}

"Input for updating a task comment."
input DesUpdateTaskCommentInput {
  "The task node ID."
  taskId: ID!
  "The comment ID."
  commentId: String!
  "New comment text."
  text: String!
}

"Input for updating a task."
input DesUpdateTaskInput {
  "The task node ID."
  taskId: ID!
  "New task name or null to keep old."
  name: String
  "New task description or null to keep old."
  description: String
  "New task priority or null to keep old."
  priority: DesTaskPriority
  "New task status or null to keep old."
  status: DesTaskStatus
}

"Input for updating a user group."
input DesUpdateUserGroupInput {
  "The group node ID."
  id: ID!
  "The group name."
  name: String!
}

"Input for updating a user."
input DesUpdateUserInput {
  "Workspace URL."
  workspaceUrl: String
  "Workspace user identifier."
  userId: String!
  "User first name."
  firstName: String
  "User last name."
  lastName: String
}

"Input for upgrading components to use the latest footprint revision."
input DesUpgradeComponentsToLatestFootprintInput {
  "The footprint identifier whose components should be upgraded."
  footprintId: ID!
  "Optional structured filter to limit which components are upgraded."
  componentFilter: DesComponentUpgradeFilterInput
}

"Input for upgrading components to use the latest symbol revision."
input DesUpgradeComponentsToLatestSymbolInput {
  "The symbol identifier whose components should be upgraded."
  symbolId: ID!
  "Optional structured filter to limit which components are upgraded."
  componentFilter: DesComponentUpgradeFilterInput
}

"Input for uploading a collaboration."
input DesUploadCollaborationInput {
  "Project identifier."
  projectId: ID!
  "The ECAD, MCAD or ESD domain."
  domain: DesCollaborationDomain!
  "The uploaded file comment."
  comment: String!
  "The uploaded file ID. Either the file ID or design must be given."
  fileId: String
  "*PROTOTYPE, SUBJECT TO CHANGE*"
  design: DesCadDesignInput
}

"Input for uploading a collaboration simulation."
input DesUploadCollaborationSimulationInput {
  "Project identifier."
  projectId: ID!
  "Domain."
  domain: String!
  "Project type."
  projectType: String!
  "Revision."
  revision: String!
  "Comment."
  comment: String!
  "Collaboration simulation files."
  files: [DesCollaborationSimulationFileInput!]!
}

"Input for uploading a project."
input DesUploadProjectInput {
  "The workspace URL."
  workspaceUrl: String
  "The uploaded zip file ID."
  fileId: String!
  "The project name."
  name: String!
  "The project description."
  description: String
  "The project target parent folder identifier."
  parentFolderId: ID!
}

"A variant contains a specific configuration of a base design."
input DesWipVariantFilterInput {
  and: [DesWipVariantFilterInput!]
  or: [DesWipVariantFilterInput!]
  "The descriptive label for this design variant."
  name: StringOperationFilterInput
}

"An attachment-valued variable associated with a workflow."
input DesWorkflowAttachmentVariableInput {
  "The variable name."
  name: String!
  "Uploaded file references."
  files: [String!]!
}

"A workflow definition contains a logical sequence of tasks."
input DesWorkflowDefinitionFilterInput {
  and: [DesWorkflowDefinitionFilterInput!]
  or: [DesWorkflowDefinitionFilterInput!]
  "The reference identifier for this workflow definition."
  workflowDefinitionId: StringOperationFilterInput
  "The label for this workflow definition."
  name: StringOperationFilterInput
  "The account information for who created this workflow definition."
  createdBy: StringOperationFilterInput
  "The `DateTime` for the creation of this workflow definition."
  createdAt: DateTimeOperationFilterInput
}

"Filter workflows by a variable."
input DesWorkflowFilterByVariableInput {
  "Name of the variable."
  name: String
  "List of value prefixes."
  valueMatchesOneOf: [String!]!
}

"A workflow manages the execution of a logical sequence of tasks."
input DesWorkflowFilterInput {
  and: [DesWorkflowFilterInput!]
  or: [DesWorkflowFilterInput!]
  "The reference identifier for this workflow."
  workflowId: StringOperationFilterInput
  "The name of the active task(s) for this workflow."
  state: StringOperationFilterInput
  "The account information for the owner of any action or response needed for this workflow."
  assignee: StringOperationFilterInput
  "The account information for who created this workflow."
  createdBy: StringOperationFilterInput
  "The `DateTime` for the creation of this workflow."
  createdAt: DateTimeOperationFilterInput
  "The `DateTime` for the completion of this workflow."
  endedAt: DateTimeOperationFilterInput
  "The label for this workflow."
  name: StringOperationFilterInput
  "The reference identifier for definition of this workflow."
  processDefinitionId: StringOperationFilterInput
  "The label for the definition of this workflow."
  processDefinitionName: StringOperationFilterInput
  "The current condition of this workflow."
  status: StringOperationFilterInput
}

"A variable belonging to the workflow."
input DesWorkflowVariableInput {
  "Type of variable."
  valueType: String
  "Workflow variable constraint. If it is \"required\", then the variable needs to be provided when launching a workflow with `desLaunchWorkflow`."
  constraint: String
  "Parameter name."
  name: String!
  "Parameter value."
  value: String!
}

"A workspace provides a flexible and secure method for managing design, manufacturing and supply content."
input DesWorkspaceFilterInput {
  and: [DesWorkspaceFilterInput!]
  or: [DesWorkspaceFilterInput!]
  "The descriptive label for this workspace."
  name: StringOperationFilterInput
  "The web address of this workspace."
  url: StringOperationFilterInput
  "The ID of this workspace used for authorization."
  authId: StringOperationFilterInput
  "The summary of this workspace content or purpose."
  description: StringOperationFilterInput
  "Tells if the workspace is the current user default."
  isDefault: BooleanOperationFilterInput
}

input ListFilterInputTypeOfDesDesignItemParameterFilterInput {
  all: DesDesignItemParameterFilterInput
  none: DesDesignItemParameterFilterInput
  some: DesDesignItemParameterFilterInput
  any: Boolean
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  or: [StringOperationFilterInput!]
  eq: String
  neq: String
  contains: String
  ncontains: String
  in: [String]
  nin: [String]
  startsWith: String
  nstartsWith: String
  endsWith: String
  nendsWith: String
}

enum DesCadBoardCollaborationFlag {
  IGNORE_DUPLICATE_PAD_DESIGNATORS
  BASELINE_UNIT_IMPERIAL
}

enum DesCadBoardComponentPlacement {
  TOP
  BOTTOM
  BOTH
}

enum DesCadBoardCopperExportFeature {
  COPPER_REGIONS
  PADS
  TRACKS
  VIAS
}

enum DesCadBoardCopperRegionType {
  REGION
  PAD
}

enum DesCadBoardLayerCategory {
  PHYSICAL
  MECHANICAL
}

enum DesCadBoardLayerComponentPlacement {
  NONE
  BODY_UP
  BODY_DOWN
}

enum DesCadBoardLayerDielectricType {
  NONE
  CORE
  PRE_PREQ
  SURFACE
  FILM
}

enum DesCadBoardLayerPhysicalCategory {
  ELECTRICAL_INTERNAL_PLANE
  ELECTRICAL_SIGNAL_LAYER
  DIELECTRICAL_ORDINAL
  DIELECTRICAL_SOLDER_MASK
  PHYSICAL_OVERLAY
  PHYSICAL_PASTE_MASK
}

enum DesCadBoardLayerPosition {
  TOP
  INTERNAL
  BOTTOM
}

enum DesCadBoardLayerType {
  DIELECTRIC
  SIGNAL
  INTERNAL_PLANE
}

enum DesCadBoardObjectType {
  COMPONENT
  HOLE
  CUTOUT
  COMPONENT_TYPE
  BOARD_AREA
  BOARD_OUTLINE
  BOARD_VIA
  LAYER
  REGION
  SPLIT_LINE
  BENDING_LINE
  TRACK
}

enum DesCadComponentVariationKind {
  FITTED
  NOT_FITTED
  ALTERNATE
}

enum DesCadCounterType {
  NONE
  COUNTERSINK_TOP
  COUNTERSINK_BOTTOM
  COUNTERBORE_TOP
  COUNTERBORE_BOTTOM
}

enum DesCadHoleType {
  CIRCULAR
  RECTANGULAR
  SLOT
  UNKNOWN
}

enum DesCadLayersExportMode {
  NO_LAYERS
  ALL_LAYERS
  OUTER_SIGNAL_LAYERS_ONLY
}

enum DesCadWorkflowState {
  NONE
  SENT_PROPOSED_CHANGES
  RECEIVED_PROPOSED_CHANGES
  READY_TO_SEND_OR_RECEIVE_CHANGES
}

"Specifies ECAD, MCAD or ESD domain."
enum DesCollaborationDomain {
  ECAD
  MCAD
  ESD
}

enum DesCommentContextType {
  NONE
  COMPONENT
  TRACK
  VIA
  AREA
}

enum DesContentTypeKind {
  COMPONENT
  EMBEDDED_DESIGN
  FPGA_DESIGN
  OPEN_BUS
  PART_CHOICE_LIST
  PCB_COMPONENT
  PCB_DESIGN
  PCB_DOCUMENT
  PCB_BLANK
  PCB_ASSEMBLY
  PCB_MODEL3D
  SCHEMATIC_SHEET
  SCHEMATIC_TEMPLATE
  SIMULATION_MODEL
  SI_MODEL
  SYMBOL
  OUTPUT_JOB
  MORFIK_PACKAGE
  MORFIK_WEB_RESOURCE
  MORFIK_X_APP_DESIGN
  MORFIK_X_APP_IMAGE
  MORFIK_X_APP_SET
  WEB_ITEM
  DXP_ADDON
  DATA_CLASS
  DEVICE_CLASS
  RICH_TEXT
  PREFERENCES
  MODEL3D
  COMPONENT_TEMPLATE
  LAYER_STACK
  BOM_TEMPLATE
  SCRIPT
  PROJECT
  PROJECT_TEMPLATE
  DATA_SHEET
  DRAFTSMAN_DOCUMENT_TEMPLATE
  DRAFTSMAN_SHEET_TEMPLATE
  PROJECT_REVIEW_PACKAGE
  PLM_INSTANCE
  PLM_PUBLISH_TEMPLATE
  PCB_BLOCK
  BINARY_FILE
  DXP_PLATFORM
  DXP_SDK
  DXP_PLUGIN
  BMS_AUTO_GENERATED_COMPONENTS
  SCHEMATIC_SNIPPET
  PCB_SNIPPET
  MANAGED_BOM
  HARNESS_LAYOUT
  HARNESS_CONNECTIVITY
  FABRICATION_FILE
  ORCAD_PROJECT
  HARNESS_LAYOUT_TEMPLATE
  HARNESS_WIRING_TEMPLATE
  PACKAGE
  MULTIBOARD_DESIGN
  HARNESS_DESIGN
  ORCAD_DESIGN
  KICAD_DESIGN
  EAGLE_DESIGN
  KICAD_PROJECT
  EAGLE_PROJECT
  ORDER_BOM
  PADS_PROJECT
  PART_REPORT
  ESD_PROJECT
  SOLUTION
  SOFTWARE_PROJECT
  DEVICE_CONFIGURATION
  SIMULATION
}

enum DesDocumentType {
  SCHEMATIC
  PCB
}

enum DesFolderFilterMatchMode {
  AND
  OR
}

enum DesFolderType {
  GENERIC_FOLDER
  ALTIUM_DESIGNER_PLUGIN_ZONE
  COMPONENT_LIBRARY
  COMPONENT_MANAGEMENT_ZONE
  DESIGN_CONTENT_MANAGEMENT_ZONE
  OUTPUTJOBS_CATALOG
  DESIGN_TEMPLATES_CATALOG
  MORFIK_PACKAGE_ZONE
  PART_CHOICE_LIST
  PCB_COMPONENT_LIBRARY
  PCB3D_MODEL_LIBRARY
  DESIGN_REUSE_BLOCKS_CATALOG
  SCHEMATIC_SNIPPETS_CATALOG
  PCB_SNIPPETS_CATALOG
  PRODUCTION_RELEASE_ZONE
  SCHEMATIC_SHEETS_CATALOG
  SCHEMATIC_SYMBOL_LIBRARY
  SCHEMATIC_TEMPLATES_CATALOG
  SIGNAL_INTEGRITY_MODELS_LIBRARY
  SIMULATION_MODELS_LIBRARY
  WEB_CONTENT_LIBRARY
  WEB_APPLICATION_DEPLOYMENT_ZONE
  MORFIK_PACKAGE_CATALOG
  MORFIK_APP_CATALOG
  MORFIK_APP_SET_CATALOG
  DATA_CLASS_CATALOG
  DATA_CLASS_ZONE
  DEVICE_CLASS_CATALOG
  DEVICE_CLASS_ZONE
  TEXT_DOCUMENT_LIBRARY
  PREFERENCES_CATALOG
  CONTENT_CART
  LIBRARY3_D
  SCRIPT_CATALOG
  PROJECT_CATALOG
  PROJECT
  COMPONENT_TEMPLATES_CATALOG
  BINARY_CATALOG
  LAYER_STACK_CATALOG
  PROJECT_TEMPLATE_CATALOG
  BOM_TEMPLATE_CATALOG
  DATASHEET_CATALOG
  DRAFTSMAN_CATALOG
  SHARED_FOLDER
  MANAGED_BOM_CATALOG
  HARNESS_LAYOUT_TEMPLATES_CATALOG
  HARNESS_WIRING_TEMPLATES_CATALOG
  PART_REPORTS_CATALOG
}

enum DesJobStatus {
  PENDING
  PROCESSING
  DONE
  ERROR
}

enum DesLayerType {
  ABSTRACT
  UNKNOWN
  PHYSICAL
  DIELECTRIC
  OVERLAY
  SOLDER_MASK
  BIKINI_COVERLAY
  PASTE_MASK
  MECHANICAL
  FOIL
  PLANE
  SIGNAL
  SURFACE_FINISH
  CORE
  PREPREG
  PLATING
  ADHESIVE
  STIFFENER
  MISC
  PE_LAYER
  CONDUCTIVE
  NON_CONDUCTIVE
}

enum DesLifeCycleManagementType {
  SIMPLE
  STRUCTURED
}

enum DesLifeCycleStateTransitionKind {
  "The transition can be applied subject to default server permissions."
  CONTROLLED
  "The transition can be applied subject to receiving approvals granted by some approval groups."
  APPROVALS
}

enum DesPadType {
  SMD
  FREE
}

enum DesParameterType {
  NONE
  TEXT
  VOLTAGE
  CURRENT
  RESISTANCE
  CONDUCTANCE
  CAPACITANCE
  CHARGE
  INDUCTANCE
  POWER
  IMPEDANCE
  FREQUENCY
  TEMPERATURE
  DECIBELS
  PERCENT
  LENGTH
  MASS
  TIME
}

enum DesPermissionScope {
  USER
  GUEST
  ANYONE
  ORGANISATION
  GROUP
  OWNER
  COLLABORATOR
}

enum DesPinElectricalType {
  INPUT
  IO
  OUTPUT
  OPEN_COLLECTOR
  PASSIVE
  HI_Z
  OPEN_EMITTER
  POWER
}

enum DesPrimitiveShape {
  NONE
  ROUND
  RECTANGLE
  OCTAGON
  CIRCLE
  ARC
  TERMINATOR
  ROUND_RECTANGLE
  ROTATED_RECTANGLE
  ROUNDED_RECTANGLE
  CUSTOM
}

enum DesProjectType {
  NONE
  PCB_PROJECT
  SYSTEM_DESIGN
  HARNESS_DESIGN
}

enum DesRevisionNamingPolicy {
  "Number whose sequence starts at 0."
  NUMERIC_ZERO
  "Number whose sequence starts at 1."
  NUMERIC_ONE
  "Upper case letters."
  ALPHA_UPPER
  "Lower case letters."
  ALPHA_LOWER
  "Revision letters per ASME Y14.35M standard: ABCDEFGHJKLMNPRTUVWY."
  ASME_Y14_35M
}

enum DesTaskPriority {
  UNDEFINED
  LOW
  MEDIUM
  HIGH
  HIGHEST
}

enum DesTaskStatus {
  UNDEFINED
  TO_DO
  IN_PROGRESS
  RESOLVED
}

enum DesUserPictureSize {
  SIZE48X48
  SIZE70X70
  SIZE128X128
  ORIGINAL
}

"Describes VCS item change kind."
enum DesVcsChangeKind {
  NONE
  ADDED
  DELETED
  MODIFIED
}

enum SupPartLifeCycle {
  UNKNOWN
  NEW
  ACTIVE
  NRFND
  EOL
  DISCONTINUED
  ACTIVE_UNCONFIRMED
  DISCONTINUED_UNCONFIRMED
  CONTACT_MFR
  TRANSFERRED
}

"Used to show the filters that are applied to current search."
type SupAppliedFilter {
  "shortname is the key in the filters Map.  Usually an attribute shortname, or `manufacturerId`, `distributorId`, etc."
  shortname: String!
  "human readable name to display in the UI"
  name: String!
  "values in the filter Map."
  values: [String!]!
  "human readable values to display in the UI"
  displayValues: [String!]!
  "The symbol of the units"
  unitsSymbol: String
}

"Defines an attribute like Capacitance or Resistance."
type SupAttribute {
  "Internal Octopart ID"
  id: ID!
  "display name"
  name: String!
  "use as key for `sort` or `filter` in part search"
  shortname: String!
  "use to group together similar attributes, e.g. Technical, Physical, Compliance"
  group: String!
  "The type of the value"
  valueType: String!
  "The short name of the units"
  unitsName: String!
  "The symbol of the units"
  unitsSymbol: String!
  "Shortened display name"
  shortDisplayname: String!
}

"Groups similar attributes together, as can be seen with column groups in specs view"
type SupAttributeGroup {
  "Name of group, e.g. Technical, Physical, Compliance"
  name: String!
  "Attributes in group"
  attributes: [SupAttribute!]!
}

"Information for use on \/electronic-parts Category pages."
type SupBlurb {
  "Category name."
  name: String!
  "Path to \/electronic-parts Category page."
  pathName: String!
  "Short description of Category."
  description: String!
  "Longer description of Category."
  content: String!
  "Description used in webpage metadata - SEO optimised"
  metaDescription: String!
  "Title used in webpage metadata - SEO optimised"
  metaTitle: String!
}

"cadAgg produces a CadBucket with the count of parts that have CAD Symbol + Footprint and 3D model"
type SupCadBucket {
  cadState: String!
  count: Int
}

"A Category exists in a Category tree.  Examples include Passive Components or Capacitors.  The `path` field is helpful to see where a category is in the tree."
type SupCategory {
  "Octopart internal id."
  id: ID!
  "ID of parent category."
  parentId: ID!
  "Display name"
  name: String!
  "List of all ancestor in category tree."
  ancestors: [SupCategory!]!
  "List of direct children in category tree."
  children: [SupCategory!]!
  "Slash separated path.  Can be used to visit URL for category page.  (e.g. `\/electronic-parts\/circuit-protection\/esd-and-circuit-protection-ics`)"
  path: String!
  "List of Attributes deemed to be relevant to this category.  (e.g. Resistance for Resistor category).  Useful for showing contextual filters in UI."
  relevantAttributes: [SupAttribute!]!
  "Blurb for Category, used on \/electronic-parts pages."
  blurb: SupBlurb
  "Number of parts in Category."
  numParts: Int!
}

"categoryAgg produces a CategoryBucket with category + counts"
type SupCategoryBucket {
  category: SupCategory!
  count: Int
}

"Internal part information for use by CircuitMaker."
type SupCircuitMakerPartInfo {
  comments: Int!
  fabrications: Int!
  projects: Int!
  rates: Int!
  releases: Int!
}

"A company record represents a manufacturer or distributor, depending on context."
type SupCompany {
  "Octopart internal id"
  id: ID!
  "Display name of company"
  name: String!
  "Aliases of company"
  aliases: [String!]!
  "The country code for the display flag"
  displayFlag: String
  "Homepage URL of company"
  homepageUrl: String
  "Used for URLs like `\/manufacturers\/aimtec` or `\/distributors\/digi-key`"
  slug: String!
  "True if a manufacturer participates in Octopart's Verified Manufacturer program.  See [verified](https:\/\/octopart.com\/verified) for more information."
  isVerified: Boolean!
  "True if a distributor is a broker.  See [authorized](https:\/\/octopart.com\/authorized) for more information."
  isBroker: Boolean! @deprecated(reason: "use `PartSeller.is_broker` instead")
  "True if a distributor has an API integration with Octopart to provide latest pricing and stock data."
  isDistributorApi: Boolean!
  "True if Octocart is supported for this distributor"
  isOctocartSupported: Boolean!
  "Custom Pricing details."
  customPricingDetails: SupCustomPricingDetails
}

"manufacturerAgg and distributorAgg produce a CompanyBucket with company + counts"
type SupCompanyBucket {
  company: SupCompany!
  count: Int
}

"contentVaultMetadataAgg produces a ContentMetadataBucket with metadata + counts"
type SupContentMetadataBucket {
  metadata: String!
  count: Int
}

type SupContentVaultMetadata {
  "Internal ID for this part."
  partId: ID!
  "Internal ID for the vault this is stored in."
  vaultId: ID!
  "Internal ID for the item in the vault this references."
  vaultItemId: ID!
  "True if the model in the content vault has symbol image."
  hasSymbol: Boolean!
  "True if the model in the content vault has footprint image."
  hasFootprint: Boolean!
  "True if the model in the content vault has 3D model."
  has3dModel: Boolean!
  "True if the model in the content vault has a thermal model."
  hasThermal: Boolean!
  "True if the model in the content vault has a simulation (SPICE) model."
  hasSimulation: Boolean!
  "Content Vault certification level"
  certificationLevel: Int
}

"A country's name, country code, and continent code."
type SupCountry {
  name: String!
  countryCode: String!
  continentCode: String!
}

type SupCreateContentVaultMetadataError {
  message: String!
}

type SupCreateContentVaultMetadataPayload {
  metadata: SupContentVaultMetadata
  errors: [SupCreateContentVaultMetadataError!]
}

type SupCustomPricingDetails {
  authType: SupCustomPricingAuthType!
}

"Textual description of a part"
type SupDescription {
  "Description text"
  text: String!
  "Source of description.  Used for attribution."
  creditString: String!
  "Source URL of description.  Used for attribution."
  creditUrl: String!
}

"Document represents a PDF file and can be a Datasheet, Compliance Document, PCN, etc."
type SupDocument {
  name: String!
  pageCount: Int
  createdAt: DateTime
  url: String!
  creditString: String!
  creditUrl: String!
  mimeType: String!
}

"DocumentCollection groups documents together by type: Datasheets, Compliance Statements."
type SupDocumentCollection {
  "Name of group, e.g. Datasheets"
  name: String!
  "List of Documents in group"
  documents: [SupDocument!]!
}

"Image of a part.  In the case of some symbol and footprint images, the scaled version may not actually be scaled and cropped, and may need to be scaled using CSS or other techniques."
type SupImage {
  urlLargest: String! @deprecated(reason: "use `url` instead")
  url55px: String! @deprecated(reason: "use `url` instead")
  url75px: String! @deprecated(reason: "use `url` instead")
  url90px: String! @deprecated(reason: "use `url` instead")
  "Image URL"
  url: String!
  "Source of description.  Used for attribution."
  creditString: String!
  "Source URL of description.  Used for attribution."
  creditUrl: String!
}

"inStockAgg produces an InStockBucket with whether it is in stock or not + counts"
type SupInStockBucket {
  isInStock: Boolean!
  count: Int
}

"cadLevelAgg and contentVaultLevelAgg produce a LevelBucket with level + displayName"
type SupLevelBucket {
  level: Int
  displayName: String!
  count: Int
}

"An offer is a specific buyable part from a distributor, with specific packaging, pricing, stock, moq."
type SupOffer {
  "Cache ID"
  _cacheId: String!
  "Octopart internal ID for this offer"
  id: ID!
  "Stock Keeping Unit used by internally by distributor"
  sku: String!
  "The code indicating the region(s) for which offer is valid"
  eligibleRegion: String
  "Number of units available to be shipped.  (aka Stock, Quantity)"
  inventoryLevel: Int!
  "Packaging of parts (eg Tape, Reel)"
  packaging: String
  "Minimum Order Quantity: smallest number of parts that can be purchased"
  moq: Int
  "The price points of the offer, sorted by minimum order quantity"
  prices: [SupPricePoint!]!
  "The URL to view offer on distributor website.  This will redirect via Octopart's server."
  clickUrl: String!
  "Octopart internal URL for this offer."
  internalUrl: String!
  "The last time data was received from distributor feed or API for this offer."
  updated: DateTime!
  "Number of days to acquire parts from factory."
  factoryLeadDays: Int
  "Number of parts on order from factory."
  onOrderQuantity: Int
  "Order multiple for factory orders."
  factoryPackQuantity: Int
  "Number of items which must be ordered together."
  orderMultiple: Int
  "The quantity of parts as packaged by the seller."
  multipackQuantity: Int
  "Whether this offer is specific to the customer making the request."
  isCustomPricing: Boolean!
}

"Part model contains the relevant data around a part, including: datasheets, specs, sellers + offers, images, etc."
type SupPart {
  "Cache ID"
  _cacheId: String!
  "Octopart internal ID for this part.  Appears at the end of PDP URL \/ `slug` field."
  id: ID!
  "manufacturer + mpn for easy display"
  name: String!
  "Manufacturer Part Number"
  mpn: String!
  "Best guess at a generic MPN"
  genericMpn: String!
  "Company that manufactures this part"
  manufacturer: SupCompany!
  "A link to the manufacturer detail page for this part or series."
  manufacturerUrl: String
  "A link to a manufacturer page to request free sample kits for this part."
  freeSampleUrl: String
  "Documents including Datasheets, Compliance Documents, PCNs"
  documentCollections: [SupDocumentCollection!]!
  "Best description around 110 characters long, as can be seen on SERP or PDP.  May need truncation if all descriptions are long."
  shortDescription: String!
  "All part descriptions from sources"
  descriptions: [SupDescription!]!
  "All part images"
  images: [SupImage!]!
  "Attribute values for this part"
  specs: [SupSpec!]!
  "Path component of PDP URL (e.g. `\/ad7792bruz-analog+devices-402798`)"
  slug: String!
  "A link to the part page on Octopart. Do not include `rel=\"nofollow\"` when linking to this URL."
  octopartUrl: String!
  "Parts identified by Octopart to be similar in specs and functionality."
  similarParts: [SupPart!]!
  "Parts identified by the manufacturer as companion products."
  companionProducts: [SupSponsoredPart!]!
  category: SupCategory
  series: SupPartSeries
  bestImage: SupImage
  bestDatasheet: SupDocument
  referenceDesigns: [SupReferenceDesign!]!
  "Data about part's CAD model.  If null `cadRequestUrl` can be used to request a CAD model be made."
  cad: SupPartCad
  "URL to request a CAD model from eeconcierge if a part doesn't already have a CAD model.  Will be null part is not eligible, e.g. a multimeter"
  cadRequestUrl: String
  "All available CAD models for this part."
  cadModels: SupPartCadModels!
  "All available simulation models for this part."
  simModels: [SupPartSimModel!]!
  "Altium content vault metadata for a given part, will return the latest revision."
  contentVaultMetadata: SupContentVaultMetadata
  "The UID from Octopart APIv3.  Provided for backwards compatibility, in general ID should be used."
  v3uid: ID!
  "A [Map](#map) of number of related objects.  Can be used to know the number of `images` or `descriptions` without having to request those related objects."
  counts: Map!
  "The median USD price at quantity 1,000, discarding outliers.  A reasonable estimate of average price for a part."
  medianPrice1000: SupPricePoint
  "Sum of stock available across all distributors"
  totalAvail: Int!
  "The average stock level at each distributor"
  avgAvail: Float!
  "Companies with Offers for this part"
  sellers(includeBrokers: Boolean! = false authorizedOnly: Boolean! = false customPricingOnly: Boolean! = false limit: Int start: Int): [SupPartSeller!]!
  "The estimated factory lead time in days derived from trusted distributor offers."
  estimatedFactoryLeadDays: Int
  "This part might be known by these alternate MPNs"
  akaMpns: [String!]!
  "Altium internal id."
  altiumInternalId: String!
  "Internal part information for use by CircuitMaker."
  circuitMakerInternal: SupCircuitMakerPartInfo
  "Nexar supply part data for internal use only."
  extras: SupPartExtras
}

type SupPartCad {
  "URL to add this part to your Upverter library. Requires an Upverter account."
  addToLibraryUrl: String
  "If true, a STEP model will be included with the tool-specific downloads."
  has3dModel: Boolean!
  hasAltium: Boolean!
  hasEagle: Boolean!
  hasOrcad: Boolean!
  hasKicad: Boolean!
  downloadUrlAltium: String!
  downloadUrlEagle: String!
  downloadUrlOrcad: String!
  downloadUrlKicad: String!
  footprintImageUrl: String
  symbolImageUrl: String
}

"PartCadDownloadURLs holds CAD model download URLs in supported formats."
type SupPartCadDownloadURLs {
  "URL to download the model in Altium Designer format."
  altium: String
  "URL to download the model in EAGLE format."
  eagle: String
  "URL to download the model in ORCA format."
  orcadSymbol: String
  "URL to download the model in KiCad format."
  kicad: String
  "URL to download the model in Vault format."
  vault: String
}

"PartCadModel represents a CAD model for the part."
type SupPartCadModel {
  "The company this model originated from."
  source: SupCompany!
  "The date the model was created or updated."
  updated: DateTime!
  "The URL to view this model on the provider website."
  cadSourceUrl: String
  "URLs to download this model, indexed by file format."
  cadDownloadUrls: SupPartCadDownloadURLs!
  "Preview URLs for this model."
  previewUrls: SupPartCadPreviewURLs!
  "True if the model contains symbols."
  hasSymbol: Boolean!
  "True if the model contains footprints."
  hasFootprint: Boolean!
  "True if the model has 3D model."
  has3dModel: Boolean!
  "The model level."
  level: Int!
  "The Style Guide version followed to create the model."
  styleGuideVersion: String
  "The Style Guide release date."
  styleGuideDate: DateTime
  "The Style Guide URL."
  styleGuideUrl: String
  "IPC compliance information."
  ipcCompliant: String
  "The datasheet used to create the model"
  datasheetUrl: String
  "The model datasheet release date."
  datasheetDate: DateTime
  "The datasheet version."
  datasheetVersion: String
  "The manufacturer from which model data was sourced."
  sourcedBy: SupCompany
}

"PartCadModels holds all available CAD models for the part."
type SupPartCadModels {
  "True if at least one model contains symbols."
  hasSymbol: Boolean!
  "True if at least one model contains footprints."
  hasFootprint: Boolean!
  "True if at least one model contains 3D geometry."
  has3dModel: Boolean!
  "The highest cad model level for this part."
  highestLevel: Int!
  "Internal viewer URL."
  viewerDownloadUrl: String
  "Available CAD models for this part"
  models: [SupPartCadModel!]!
}

"PartCadPreviewURLs holds CAD model preview URLs."
type SupPartCadPreviewURLs {
  "URLs of footprint preview images, indexed by image type (e.g. resolution, format). If not empty, the map contains a 'default' key pointing to the preferred image to use."
  footprint: Map
  "URLs of symbol preview images, indexed by image type (e.g. resolution, format). If not empty, the map contains a 'default' key pointing to the preferred image to use."
  symbol: Map
  "URLs of 3D model preview images, indexed by image type (e.g. resolution, format). If not empty, the map contains a 'default' key pointing to the preferred image to use."
  threeD: Map
}

type SupPartMatch {
  "Will match `reference` supplied in PartMatchQuery."
  reference: String
  "Number of parts matched"
  hits: Int!
  "Matched parts (may be subset, based on start + limit)"
  parts: [SupPart!]!
  "Possible error message"
  error: String
}

"An individual part offer."
type SupPartOffer {
  partId: String!
  sellerId: String!
  offer: SupOffer!
}

type SupPartResult {
  "Cache ID"
  _cacheId: String!
  "The part object"
  part: SupPart!
  explain: String! @deprecated(reason: "always empty")
  "If the search `q` is an alternate MPN for this part, the `akaMpn` will be populated with this alternate MPN."
  akaMpn: String
  "Description with query terms highlighted.  Often this is the same as part.shortDescription,\nbut if the search `q` matched on a different description it may be longer than part.shortDescription and require truncation."
  description: String!
}

"Result of part search."
type SupPartResultSet {
  total: Int! @deprecated(reason: "use `hits` instead")
  "Number of parts in result set"
  hits: Int!
  "Contains nested part along side some fields specific to the query that explain reason for match."
  results: [SupPartResult!]
  "Grouped attributes used to render the columns in specs view."
  specsViewAttributeGroups: [SupAttributeGroup!]!
  "If an invalid query was modified or rejected, warnings indicate this fact to the user.  For example if query contained too many tokens, some tokens may be ignored."
  warnings: [String!]
  "Perform aggregations on Spec values across multiple Attributes.\nYou *must* specify `attributeNames` for this field to be populated.\n`attributeNames` should be a list of Attribute.shortname values (e.g. `capacitance` or `voltageRatingDc`)\n- You can set `attributeSelection=WITHSUGGESTED` to additionally include suggested attributes for aggregation\n- Alternatively, set `attributeSelection=ALL` to include all attributes for aggregation\n- To rely solely on suggested attributes, set `attributeSelection=WITHSUGGESTED` and `attributeNames=[]`"
  specAggs("a list of Attribute.shortname values to aggregate on (e.g. `capacitance` or `voltageRatingDc`)" attributeNames: [String!]! "defines how attributes are selected for aggregation (default EXPLICIT)" attributeSelection: SupSpecAggsSelection! = EXPLICIT "number of spec value buckets to return (default 10)" size: Int! = 10): [SupSpecAgg!]!
  "Aggregate on manufacturers for this result set"
  manufacturerAgg("number of buckets to return (default 10)" size: Int! = 10): [SupCompanyBucket!]!
  "Aggregate on distributors for this result set"
  distributorAgg("number of buckets to return (default 10)" size: Int! = 10): [SupCompanyBucket!]!
  "Aggregate on categories for this result set"
  categoryAgg("number of buckets to return (default 10)" size: Int! = 10): [SupCategoryBucket!]!
  "Aggregate on the availability of CAD models for the result set"
  cadAgg: [SupCadBucket!]!
  "Aggregate on CAD levels for this result set"
  cadLevelAgg: [SupLevelBucket!]!
  "Aggregate on Altium content metadata levels"
  contentVaultLevelAgg: [SupLevelBucket!]!
  "Aggregate on Altium content metadata"
  contentVaultMetadataAgg: [SupContentMetadataBucket!]!
  "Aggregate on whether the parts are in stock for this result set"
  inStockAgg: [SupInStockBucket!]!
  "Categories that are determined by search algo to be related to the search term.  Useful for suggesting a Category filter in the search UI."
  suggestedCategories: [SupCategoryBucket!]!
  "Attributes that are determined by search algo to be related to the search term.  Useful for suggesting most relevant filters in the search UI."
  suggestedFilters: [SupAttribute!]!
  "Full list of available Attributes in the result set"
  allFilters(sort: SupAllFiltersSort! = default): [SupAttribute!]!
  "If a Category filter is applied, this will be the Category"
  appliedCategory: SupCategory
  "If filters are applied, this will contain display information"
  appliedFilters: [SupAppliedFilter!]!
}

"A company with offers for a given part"
type SupPartSeller {
  "Cache ID"
  _cacheId: String!
  "The distributor"
  company: SupCompany!
  "Distributor's country"
  country: String
  "List of offers.  Multiple offers may exist in different packaging.\nWhile multiple geo-targeted offers may exist, currently the API only exposes one geo-targeted offer at a time based on `country` parameter.\nPlease contact us if you have a need to see all geo-targeted offer variants."
  offers(priceBreaks: [Int!]): [SupOffer!]!
  "True if the distributor is an authorized distributor for this manufacturer.  See [authorized](https:\/\/octopart.com\/authorized) for more information."
  isAuthorized: Boolean!
  "True if the distributor is a Non-Authorized Dealer.  See [authorized](https:\/\/octopart.com\/authorized) for more information."
  isBroker: Boolean!
  "True if you can request a quote from this seller."
  isRfq: Boolean!
  "List of countries the seller ships to. An empty list represents zero shipping restrictions."
  shipsToCountries: [SupCountry!]!
}

"A Part can be a member of a PartSeries, which represents a product line or \"family\" of parts from the manufacturer.\n\nSee [series](https:\/\/octopart.com\/series) page for examples."
type SupPartSeries {
  "Octopart internal ID for this series"
  id: ID!
  "Name of the part series"
  name: String!
  "Octopart URL for this series, specific to the parent part"
  url: String!
}

"PartSimModel represents a simulation model."
type SupPartSimModel {
  "The company this model originated from."
  source: SupCompany!
  "The URL to download this model."
  downloadUrl: String!
  "The model metadata items."
  items: [SupPartSimModelItem!]!
}

"PartSimModelItem holds a metadata attribute for a simulation model."
type SupPartSimModelItem {
  itemName: String!
  itemType: String!
  fileName: String!
}

"Price in a specific currency + quantity.  By supplying a `currency` parameter the API will populate an estimated convertedPrice in the user's desired currency."
type SupPricePoint {
  "Cache ID"
  _cacheId: String!
  "Minimum purchase quantity to get this price (aka price break)"
  quantity: Int!
  "Price in currency"
  price: Float!
  "Currency for price"
  currency: String!
  "Price converted to user's currency using foreign exchange rates.\n\nSince this is an estimate, an indicator should be shown to user if currency != convertedCurrency."
  convertedPrice: Float!
  "Currency for `convertedPrice`.  Will match value of `currency` argument."
  convertedCurrency: String!
  "The exchange rate used to calculate convertedPrice"
  conversionRate: Float!
}

type SupReferenceDesign {
  name: String!
  url: String!
}

type SupSearchCorrection {
  correctionString: String!
  droppedTerms: [String!]!
  hits: Int!
}

"Represents a specific value of an Attribute for a given Part"
type SupSpec {
  attribute: SupAttribute!
  "The actual value"
  value: String!
  "The value of the spec in SI base units"
  siValue: String!
  "The type of the value"
  valueType: String!
  "The units of the value"
  units: String!
  "The short name of the units"
  unitsName: String!
  "The symbol of the units"
  unitsSymbol: String!
  "The formatted display value"
  displayValue: String!
}

type SupSpecAgg {
  attribute: SupAttribute!
  buckets: [SupSpecBucket!]!
  "min is the lowest spec value in this result set for numerical attributes"
  min: Float
  "max is the greatest spec value in this result set for numerical attributes"
  max: Float
  "The min value in SI base units"
  siMin: String
  "The max value in SI base units"
  siMax: String
  "displayMin is the formatted string of min"
  displayMin: String
  "displayMax is the formatted string of max"
  displayMax: String
  "The type of the value"
  valueType: String!
  "The units of the spec"
  units: String
  "The short name of the units"
  unitsName: String
  "The symbol of the units"
  unitsSymbol: String
}

type SupSpecBucket {
  "displayValue is the string value. For numerical attributes it is the formatted version of floatValue"
  displayValue: String!
  "floatValue is populated if the attribute is numeric"
  floatValue: Float
  "count will be null if aggregation timed out"
  count: Int
}

type SupSpellingCorrection {
  correctionString: String!
  hits: Int!
}

"Part identified by manufacturer as being a companion part, for instance a mated connector pair."
type SupSponsoredPart {
  "Cache ID"
  _cacheId: String!
  ppid: ID! @deprecated(reason: "use part.id instead")
  sourceId: ID! @deprecated(reason: "unused")
  "Related part"
  part: SupPart!
  "URL to visit for related part"
  url: String!
}

"Suggests a query based on partial query input.  Used for autocomplete \/ typeahead UIs."
type SupSuggestion {
  "Suggested text of longer query"
  text: String!
  "If the suggestion should also apply a categoryId filter, this is the category name"
  inCategoryName: String!
  "If the suggestion should also apply a categoryId filter, this is the Category ID"
  inCategoryId: String!
  "If the suggestion should also apply a manufacturer filter, this is the Manufacturer name"
  inManufacturerName: String!
  "If the suggestion should also apply a partId filter, this is the Part ID"
  inPartId: String!
}

input SupApiCredentials {
  "The ID of the company that you are providing credentials for. An Octopart representative will give this value to you if needed."
  companyId: String!
  "Authentication details. `clientId` and `clientSecret` should be given together when an API requires them."
  clientId: String
  "Authentication details. `clientId` and `clientSecret` should be given together when an API requires them."
  clientSecret: String
  "Authentication details. `username` and `password` should be given together when an API requires them."
  username: String
  "Authentication details. `username` and `password` should be given together when an API requires them."
  password: String
  "Authentication details. `apiKey` should be given when an API requires it."
  apiKey: String
}

input SupCreateContentVaultMetadataInput {
  "Internal ID for this part."
  partId: ID!
  "Internal Vault ID."
  vaultId: ID!
  "Internal Vault model ID."
  vaultItemId: ID!
  "Creation timestamp."
  createTimestamp: DateTime!
  "Internal model UUID"
  octopartModelUuid: String
  "True if the model has symbols."
  hasSymbol: Boolean
  "True if the model has footprints."
  hasFootprint: Boolean
  "True if the model has 3D geometries."
  has3dModel: Boolean
  "True if the model has thermal data."
  hasThermal: Boolean
  "True if the model has simulation data."
  hasSimulation: Boolean
  "Content Vault certification level"
  certificationLevel: Int
}

"A reference to a part offer."
input SupOfferReference {
  partId: String!
  offerId: String!
}

input SupPartMatchOptions {
  "If true, only parts with at least one authorized seller will be returned."
  requireAuthorizedSellers: Boolean = false
  "If true, only parts with stock available will be returned."
  requireStockAvailable: Boolean = false
  "a key: value map of filters. See [filter values](https:\/\/octopart.com\/api\/v4\/values#attributes)"
  filters: Map
}

input SupPartMatchQuery {
  mpn: String
  sku: String
  mpnOrSku: String
  manufacturer: String
  seller: String
  start: Int! = 0
  limit: Int! = 3
  reference: String
}

enum SupAllFiltersSort {
  default
  "Relevance is determined by the number of parts in the result set that have the attribute"
  relevance
}

"Specify root to include in categories query.\nDefaults to Electronic parts root only"
enum SupCategoryRoot {
  "Electronic parts root"
  ElectronicParts
  "Application root"
  Application
}

enum SupCustomPricingAuthType {
  CLIENT_CREDENTIALS
  USERNAME_PASSWORD
  API_KEY
}

enum SupNexarFeatureID {
  LEAD_TIME
  LIFECYCLE
  DATASHEETS
  TECH_SPECS
  CAD_MODELS
  SIMILAR_PARTS
  SUGGESTIONS
  SPELLING_CORRECTIONS
  INVENTORY_HISTORY
  ALTIUM_CONTENT_METADATA
}

enum SupPlanTier {
  FREE
  BASIC
  PRO
  ENTERPRISE
}

enum SupRole {
  DISTRIBUTOR
  CADMODELS
  INTERNAL
  NEXARINTERNAL
}

"Specify method on ranking search results."
enum SupSearchRankingMethod {
  "Default Ranking for all searches."
  DEFAULT
  "Ranking the result for Supply purpose."
  SUPPLY
  "Ranking the result for Design purpose."
  DESIGN
}

enum SupSortDirection {
  asc
  desc
}

enum SupSpecAggsSelection {
  EXPLICIT
  WITH_SUGGESTED
  ALL
}

interface Error {
  message: String!
}

type SupEvalKit {
  "The evaluation kit identifier."
  id: ID!
  "The evaluation kit title."
  title: String!
  "The detailed description."
  description: String
  "The source url."
  sourceUrl: String
  "The creation date."
  createdAt: DateTime
  "The last updated date."
  updatedAt: DateTime
  "The list of evaluation kit images."
  previewImages: [SupImage!]
  "The best evaluation kit images."
  bestPreviewImage: SupImage
  "The list of part identifiers associated with the evaluation kit."
  partIds: [String!]! @deprecated(reason: "Fields play a technical role for schema stitching purposes.")
  "The list of reference design identifiers associated with the evaluation kit."
  refDesignIds: [String!]! @deprecated(reason: "Fields play a technical role for schema stitching purposes.")
  refDesigns: [SupRefDesign!]!
  "The list of compatible software project identifiers associated with the evaluation kit."
  compatibleSoftwareProjectIds(start: Int! = 0 limit: Int! = 100): [ID!]! @deprecated(reason: "Fields play a technical role for schema stitching purposes.")
  compatibleSoftwareProjects: [SupSoftwareProject!]!
  "The esd source."
  esdSource: SupEvalKitESDSource
  parts: [SupPart]!
}

"Payload associated with creating a evaluation kit."
type SupEvalKitCreateEvalKitPayload {
  "Evaluation kit identifier."
  id: ID
  errors: [SupEvalKitCreateEvalKitError!]
}

"Payload associated with deleting a evaluation kit."
type SupEvalKitDeleteEvalKitPayload {
  errors: [SupEvalKitDeleteEvalKitError!]
}

type SupEvalKitESDSource {
  documentFileUrl: String
  compileModelUrl: String
}

type SupEvalKitNotFoundError implements Error {
  message: String!
  errorCode: SupEvalKitErrorCode!
}

type SupEvalKitOperationFailedError implements Error {
  message: String!
  errorCode: SupEvalKitErrorCode!
}

"Payload associated with updating a evaluation kit."
type SupEvalKitUpdateEvalKitPayload {
  errors: [SupEvalKitUpdateEvalKitError!]
}

union SupEvalKitCreateEvalKitError = SupEvalKitOperationFailedError

union SupEvalKitDeleteEvalKitError = SupEvalKitOperationFailedError | SupEvalKitNotFoundError

union SupEvalKitUpdateEvalKitError = SupEvalKitOperationFailedError | SupEvalKitNotFoundError

"Input for evaluation kit creation."
input SupEvalKitCreateEvalKitInput {
  "The evaluation kit title."
  title: String!
  "The evaluation kit description."
  description: String
  "The evaluation kit description."
  sourceUrl: String
  "The list of Reference Design identifiers associated with the evaluation kit."
  refDesignIds: [ID!]
  "The list of evaluation kit images input. The first image will be the best preview image."
  previewImages: [SupEvalKitFileInput!]!
  "The list of Part identifiers associated with the evaluation kit."
  partIds: [String!]
  "The list of Compatible Software Project identifiers associated with the evaluation kit."
  compatibleSoftwareProjectIds: [ID!]
}

"Input for evaluation kit delete."
input SupEvalKitDeleteEvalKitInput {
  "The evaluation kit identifier."
  id: ID!
}

input SupEvalKitFileInput {
  fileId: String!
  fileType: String!
  fileName: String!
}

"Input for evaluation kit update."
input SupEvalKitUpdateEvalKitInput {
  id: ID!
  "The evaluation kit title."
  title: String
  "The evaluation kit description."
  description: String
  "The evaluation kit description."
  sourceUrl: String
  "Remove list of Reference Design identifiers associated with the evaluation kit."
  removeRefDesignIds: [ID!]
  "Add list of Reference Design identifiers associated with the evaluation kit."
  addRefDesignIds: [ID!]
  "Remove list of Part identifiers associated with the evaluation kit."
  removePartIds: [String!]
  "Add list of Part identifiers associated with the evaluation kit."
  addPartIds: [String!]
  "Replace the current evaluation kit preview images with these ones. The first image will be used as a best preview image."
  newPreviewImages: [SupEvalKitFileInput!]
  "Add list of Compatible Software Project identifiers associated with the evaluation kit."
  addCompatibleSoftwareProjectIds: [ID!]
  "Remove list of Compatible Software Project identifiers associated with the evaluation kit."
  removeCompatibleSoftwareProjectIds: [ID!]
}

enum SupEvalKitErrorCode {
  OPERATION_FAILED
  SUP_EVAL_KIT_NOT_FOUND
}

"Shared Fields between `SupPartFamily` and `SupPartGroup`."
interface SupPartFamilyEntity {
  id: ID!
  stableName: String!
  title: String!
  subtitle: String!
  overview: String!
  categoryID: String!
  manufacturerID: String!
  applicationIDs: [String!]!
  tags: [SupPartFamilyTag!]!
  keyFeatures: [SupPartFamilyKeyFeature!]!
}

"`SupPartFamily` contains the relevant information related to a part family.\nIt exists in a hierarchy of other part families, they can contain children which represent other part families or\n`partGroups` which represent the leaves of the hierarchy tree."
type SupPartFamily implements SupPartFamilyEntity {
  "`id` is the global resource id (GRID) for this Part Family."
  id: ID!
  "`stableName` is an immutable name of this part family."
  stableName: String!
  "`familyType` describes the part family in a part family hierarchy.\nIt is vendor and part family specific.\nExamples include: 'Series', 'Family', etc."
  familyType: String!
  "`parent` is the the direct parent of this family. This will be `null` if this is the highest level."
  parent: SupPartFamily
  "`children` is a list of the part families that are the direct children of this family.\nThere will be one of either `children` or `partGroups`."
  children: [SupPartFamily!]!
  "`partGroups` is a list of the part groups that are the direct children of this family.\nThere will be one of either `children` or `partGroups`."
  partGroups: [SupPartGroup!]!
  "`siblings` is a list of direct sibling part families of the current group, which have the same parent.\nThey are usually a close alternative choice of the current group."
  siblings: [SupPartFamily!]!
  "`title` of the part family."
  title: String!
  "`subtitle` of the part family."
  subtitle: String!
  "`overview` of the part family."
  overview: String!
  "`categoryID` is the identifier of the part category of this part family."
  categoryID: String!
  "`applicationIDs` is a list of the identifiers of relevant applications this part family can be useful for."
  applicationIDs: [String!]!
  "`tags` is a list of additional metadata for categorizing this part family."
  tags: [SupPartFamilyTag!]!
  "`keyFeatures` is the list of key part features relevant to this part family."
  keyFeatures: [SupPartFamilyKeyFeature!]!
  "`manufacturerID` is the identifier of the manufacturer of this part family."
  manufacturerID: String!
  category: SupCategory!
  applications: [SupCategory!]
  manufacturer: [SupCompany!]
}

"Used to show the filters that are applied to current search."
type SupPartFamilyAppliedFilter {
  "Name of the filter applied, will match the filter key used in the search."
  name: String!
  "Human readable name to display in the UI."
  displayName: String!
  "Values in the filter Map."
  values: SupPartFamilyFilterValues!
  "Human readable values to display in the UI."
  displayValues: [String!]!
  "The units of the values."
  units: String
}

"`SupPartFamilyComplementaryPart` contains the details of the complementary part for this part group."
type SupPartFamilyComplementaryPart {
  "`partGroupID` is the GRID of the part group."
  partGroupID: ID!
  "`name` of the part or part group."
  name: String!
  "`categoryID` of the category of this part or part group."
  categoryID: String!
  "`slug` is the url slug for this part or part group on Octopart."
  slug: String!
  "`lifecycle` status of this part or part group."
  lifecycle: String!
}

"`SupPartFamilyDocument` contains the details for the documentation provided for a Part Family.\n`url` contains a link to the given document.\n`updatedAt` is the time we last updated this document."
type SupPartFamilyDocument {
  type: SupPartFamilyDocumentType!
  description: String!
  url: String!
  updatedAt: DateTime!
}

"`SupPartFamilyFeatureMetadata` contains additional information about a given feature."
type SupPartFamilyFeatureMetadata {
  name: String!
  value: String!
  displayValue: String!
  units: String!
}

"Values applied within the filter."
type SupPartFamilyFilterValues {
  values: [String]
  min: String
  max: String
}

"`SupPartFamilyKeyFeature` contains the key details for a Part Family feature."
type SupPartFamilyKeyFeature {
  name: String!
  group: String!
  value: String!
  valueType: SupPartFamilyFeatureValueType!
  displayValue: String!
  units: String!
  metadata: [SupPartFamilyFeatureMetadata!]!
}

"`SupPartFamilyParameter` is the parameter definition for a filterable parameter of a part group."
type SupPartFamilyParameter {
  "Name of this parameter."
  name: String!
  "Formatted name for use in the UI."
  displayName: String!
  "Methods of filtering available for this parameter."
  filterTypes: [SupPartFamilyFilterType!]!
  "Aggregation of parameter values."
  parameterAgg: SupPartFamilyParameterAgg!
}

"Aggregation of parameter values, `buckets` contains aggregations of the different parameter values.\nWill contain a `min`, `max`, and `units` if the parameter is a numeric value."
type SupPartFamilyParameterAgg {
  "Aggregation buckets for this parameter.\n'size' specifies the number of aggregation buckets to include."
  buckets(size: Int = 10): [SupPartFamilyParameterBucket!]!
  "Min value of this parameter, if this is a numeric parameter."
  min: Float
  "Max value of this parameter, if this is a numeric parameter."
  max: Float
  "Units of this parameter, if this is a numeric parameter."
  units: String
}

"Aggregation bucket for parameter values.\nIf the parameter is discrete it will be a terms aggregation.\nIf the parameter is numeric it will be a range aggregation and `min`, `max` will be populated."
type SupPartFamilyParameterBucket {
  displayValue: String!
  min: Float
  max: Float
  count: Int!
}

"Represents a part object from the supply schema."
type SupPartFamilyPart {
  "Nexar ID of the part this object represents."
  partID: ID!
  "Nexar supply part data for internal use only. Array of size 1."
  part(country: String! = "US" currency: String! = "USD"): [SupPart]!
}

"`SupPartFamilyPartResultSet` is the search results with pagination information."
type SupPartFamilyPartResultSet {
  "Total number of part and\/or groups found."
  hits: Int!
  "List of part or part groups in the current result set."
  results: [SupPartFamilyPartSearchResult!]!
  "List of filters that were applied to this search."
  appliedFilters: [SupPartFamilyAppliedFilter!]!
}

"`SupPartFamilyPrice` contains the min and max price of parts in the group. Sourced from octopart part offers."
type SupPartFamilyPrice {
  "`min` is the minimum price of any part in this group."
  min: Float!
  "`max` is the maximum price of any part in this group."
  max: Float!
  "`median` is the median price of the parts in this group."
  median: Float!
  "`priceBreak` is the quantity break at which the prices were calculated."
  priceBreak: Int!
  "`currency` of the price provided."
  currency: String!
}

"`SupPartFamilyResultSet` is the search results with pagination and aggregation information."
type SupPartFamilyResultSet {
  "Total number of part families and\/or groups found."
  hits: Int!
  "List of part families or part groups in the current result set."
  results: [SupPartFamilySearchResult!]!
}

"`SupPartFamilySoftwareSupport` contains the details for the software support provided for a Part Family.\n`url` contains a link to the given software support package.\n`updatedAt` is the time we last updated this document."
type SupPartFamilySoftwareSupport {
  title: String!
  url: String!
  updatedAt: DateTime!
}

"`SupPartFamilyTag` represents additional metadata for a Part Family."
type SupPartFamilyTag {
  type: String!
  value: String!
}

"`SupPartFamilyVideo` contains the details and link for a given training video."
type SupPartFamilyVideo {
  "Title of this training video."
  title: String!
  "URL at which this video can be accessed."
  url: String!
  "URL at which the video thumbnail can be accessed."
  thumbnailUrl: String!
  "Time at which we last updated this video."
  updatedAt: DateTime!
}

"`SupPartGroup` contains the relevant information relating to a part group.\nIt represents the leaves of the Part Family hierarchy, and contain the parts represented by this group."
type SupPartGroup implements SupPartFamilyEntity {
  "`id` is the global resource id (GRID) for this Part Group."
  id: ID!
  "`stableName` is an immutable name of this part family."
  stableName: String!
  "`parent` is the the part family representing the direct parent of this group."
  parent: SupPartFamily
  "`siblings` is a list of direct sibling part groups of the current group, which have the same parent.\nThey are usually a close alternative choice of the current group."
  siblings: [SupPartGroup!]!
  "`title` of the part group."
  title: String!
  "`subtitle` of the part group."
  subtitle: String!
  "`overview` of the key details of this part group."
  overview: String!
  "`categoryID` is the identifier of the part category of this part group."
  categoryID: String!
  "`applicationIDs` is a list of the identifiers of relevant applications this part group can be useful for."
  applicationIDs: [String!]!
  "`tags` is a list of additional metadata for categorizing this part group."
  tags: [SupPartFamilyTag!]!
  "`lifecycleStatus` is an enum representing the normalized lifecycle status of this part group."
  lifecycleStatus: SupPartFamilyLifecycleStatus!
  "`keyFeatures` is the list of key part features relevant to this part group."
  keyFeatures: [SupPartFamilyKeyFeature!]!
  "`manufacturerID` is the identifier of the manufacturer of this part group."
  manufacturerID: String!
  "`partIDs` is the list of identifiers of the physical parts within this group.\nstart and limit are used for paging part results (including those under the parts field).\nlimit has a max value of 20, any value greater than this will be reduced to it."
  partIDs(start: Int! = 0 limit: Int! = 10): [String!]!
  "`price` contains pricing information for this part group.\nIt contains the minimum, maximum, and median unit price @ given quantity among all parts in the group."
  price(country: String! = "US" currency: String! = "USD" quantity: Int! = 1000): SupPartFamilyPrice
  "`complementaryParts` is a list of the identifiers of relevant parts which work with this group."
  complementaryParts: [SupPartFamilyComplementaryPart!]!
  "`referenceDesignIDs` is a list of the identifiers of reference designs relevant to this part group."
  referenceDesignIDs: [String!]!
  "`documents` is a list of the key documentation related to this part group."
  documents(type: SupPartFamilyDocumentType): [SupPartFamilyDocument!]!
  "`softwareSupport` is a list of the key supporting documents for this part group."
  softwareSupport: [SupPartFamilySoftwareSupport!]!
  "`videos` is a list of key videos related to this part group."
  videos: [SupPartFamilyVideo!]!
  category: SupCategory!
  applications: [SupCategory]!
  manufacturer: [SupCompany!]
  parts: [SupPart]!
}

union SupPartFamilyPartSearchResult = SupPartFamilyPart | SupPartGroup

union SupPartFamilySearchResult = SupPartFamily | SupPartGroup

input SupPartFamilyFilterInput {
  applicationIDs: [String!]
  categoryIDs: [String!]
  manufacturerIDs: [String!]
}

"Valid document types for Part Family documentation."
enum SupPartFamilyDocumentType {
  DATASHEET
  MANUAL
  APPLICATION_NOTE
  REPORT
  BROCHURE
  FLYER
  GUIDE
  OTHER
}

"Valid types a features value can take."
enum SupPartFamilyFeatureValueType {
  STRING
  SCALAR
  RANGE
  ENUMERATION
}

"Valid types for a parameter filter. These describe how this parameter can be used in filtering.\n`VALUES` indicates the parameter can be filtered based on a provided set of terms.\n`RANGE` indicates the parameter can be filtered based on a range of values, provided a min and max value."
enum SupPartFamilyFilterType {
  VALUES
  RANGE
}

enum SupPartFamilyLifecycleStatus {
  NEW
  PRODUCTION
  EOL
  NRND
  OBSOLETE
  UNKNOWN
}

type SupRefApplicationBucket {
  applicationId: String!
  count: Int!
  application: [SupCategory!]
}

type SupRefCategoryBucket {
  categoryId: String!
  count: Int!
  category: [SupCategory!]
}

"A reference design model aggregates the relevant documents, files and parts."
type SupRefDesign {
  "The reference design identifier."
  id: ID!
  "The reference design title."
  title: String!
  "The stable name identifier."
  stableName: String!
  "The subtitle providing context."
  subtitle: String
  "The detailed description."
  description: String!
  "The type identifier of this reference design."
  type: SupRefDesignType!
  "The source URL where the reference design is published."
  sourceUrl: String
  "Indicates whether the reference design is verified."
  isVerified: Boolean!
  "The creation date."
  createdAt: DateTime
  "The last updated date."
  updatedAt: DateTime
  "Indicates if an evaluation board is available."
  hasEvalBoard: Boolean!
  "The publisher identifier."
  publisherId: String!
  "The bill of materials (BOM) identifier."
  bomId: String
  "The default schematic file associated with the reference design."
  defaultSchematicFile: String
  "The status name."
  status: SupRefDesignStatus
  "Part identifiers of the reference design, including their designators."
  parts(designators: [String!] type: SupRefPartType @deprecated(reason: "Use 'types' instead") types: [SupRefPartType] start: Int! = 0 limit: Int! = 50): [SupRefPart]!
  "The list of application identifiers related to the reference design."
  applicationIds: [String!]!
  "The list of evaluation kit identifiers associated with the reference design."
  evaluationKitIds: [String!]! @deprecated(reason: "Use 'evaluationKits' instead.")
  "Preview images that provide a visual overview of the reference design."
  previewImages: [SupImage]
  "Frequently asked questions about the reference design."
  faqs: [SupRefFaq!]!
  "Key features highlighting the capabilities of the reference design."
  keyFeatures: [SupRefKeyFeature]!
  "Design files, such as schematics and layouts, for the reference design."
  designFiles(type: String extensions: [String!]): [SupRefDesignFile]!
  "Documentation resources related to the reference design."
  documentations: [SupDocument]!
  "Tags categorizing the reference design for search and organization."
  tags: [SupRefTag]
  "Software packages and resources associated with the reference design."
  softwares: [SupRefResource]!
  "The list of evaluation kits associated with the reference design."
  evaluationKits: [SupRefEvaluationKit!]
  publisher: [SupCompany!]
  applications: [SupCategory!]
}

"Represents a design file belonging to a reference design."
type SupRefDesignFile {
  "The design file identifier."
  refDesignFileId: String!
  "The design file name."
  name: String!
  "The design file download URL."
  url: String!
  "The design file type."
  type: String!
  "The design file extension."
  extension: String!
  "Notes attached to the design file."
  notes: [SupRefDesignNote]!
}

"Represents a note attached to a reference design file."
type SupRefDesignNote {
  "The note title."
  title: String!
  "The note description."
  description: String
  "The note identifier."
  objectId: String
  "The attached resource for the note."
  attachment: SupDocument
  "Points representing the position of the note attached on the design file."
  points: [SupRefPoint2D]!
}

"Reference designs with pagination, aggregation information."
type SupRefDesignResultSet {
  "Total number of reference designs found."
  hits: Int!
  "List of reference designs in the current result set."
  results: [SupRefDesign!]!
  "Aggregate on publishers for this result set."
  publisherAgg(size: Int = 10): [SupRefPublisherBucket!]
  "Aggregate on applications for this result set."
  applicationAgg(size: Int = 10): [SupRefApplicationBucket!]
  "Aggregate on tags for this result set."
  tagAgg(size: Int = 10): [SupRefTagBucket!]
  "Aggregate on categories for this result set."
  categoryAgg(size: Int = 10): [SupRefCategoryBucket!]
  "Aggregate on reference design types for this result set."
  typeAgg(size: Int = 10): [SupRefDesignTypeBucket!]
}

type SupRefDesignTypeBucket {
  type: SupRefDesignType!
  count: Int!
}

type SupRefEvaluationKit {
  "The part identifier."
  partId: String!
  "The evaluation kit title."
  title: String!
  "Preview images that provide a visual overview of the evaluation kit."
  previewImages: [SupImage!]!
  "Nexar supply part data for internal use only. Array of size 1."
  evalKit(country: String! = "US" currency: String! = "USD"): [SupPart]!
}

"Represents a frequently asked question for a reference design."
type SupRefFaq {
  "The question text."
  question: String!
  "The answer text."
  answer: String!
}

"Represents a key feature of a reference design."
type SupRefKeyFeature {
  "The feature name."
  name: String!
  "The feature description."
  description: String!
  "The feature description in HTML format."
  html: String
}

type SupRefPart {
  "The part identifier."
  partId: String!
  "The type identifier of this component, indicating its role in the reference design."
  type: SupRefPartType!
  "The global identifier linked to the reference design components."
  designators: [String!]!
  "Nexar supply part data for internal use only. Array of size 1."
  part(country: String! = "US" currency: String! = "USD"): [SupPart]!
}

"Represents a 2D point for a file note."
type SupRefPoint2D {
  "The point type."
  type: String!
  "The X coordinate."
  x: Float!
  "The Y coordinate."
  y: Float!
}

type SupRefPublisherBucket {
  publisherId: String!
  count: Int!
  publisher: [SupCompany!]
}

"Represents a resource related to a reference design."
type SupRefResource {
  "The resource title."
  title: String!
  "The resource description."
  description: String!
  "An optional note for the resource."
  note: String
  "The information of the download URL."
  downloadText: String!
  "The download URL for the resource."
  downloadUrl: String!
  "The revision date for the resource."
  revisionDate: DateTime!
  "Other related resources."
  otherResources: [SupRefResource]!
}

"Represents a tag for categorizing a reference design."
type SupRefTag {
  "The tag value."
  value: String!
  "The tag category name."
  category: String!
}

type SupRefTagBucket {
  name: String!
  count: Int!
}

input SupRefDesignFilterInput {
  isVerified: Boolean
  hasEvalBoard: Boolean
  applicationIds: [String!]
  categoryIds: [String!]
  publisherIds: [String!]
  tags: [String!]
  types: [SupRefDesignType!]
  statuses: [SupRefDesignStatus!]
}

enum SupRefDesignStatus {
  "Work in progress, not yet submitted for review."
  DRAFT
  "Design data has been submitted and awaits review."
  SUBMITTED
  "Review or progress is paused pending further action."
  ON_HOLD
  "The design is currently under review."
  REVIEWING
  "The design was reviewed and rejected."
  REJECTED
  "The design is approved and published and it has active status."
  ACTIVE
  "The design is not active."
  INACTIVE
}

enum SupRefDesignType {
  "Highlights a component feature, often for marketing or sales purposes."
  DEMONSTRATION
  "Intended to test specific electrical\/mechanical characteristics."
  EVALUATION
  "Enables code\/hardware development and prototyping."
  DEVELOPMENT
  "Bundled offering to help users ramp up quickly."
  STARTER
  "Complete application or subsystem design with documentation."
  REFERENCE_DESIGN
  "Extends capabilities of a dev board. Often optional."
  EXPANSION
  "Combines multiple board types, sensors, or modules into a full system."
  SYSTEM
}

enum SupRefPartType {
  "Main parts that the reference design demonstrate."
  PRIMARY
  "Important supporting parts essential to the function of the reference design."
  KEY
  "Other supporting parts."
  OTHER
}

type SupSoftwareProject {
  "The software project identifier."
  id: ID!
  "The software project title."
  title: String!
  "The detailed description."
  description: String
  "The software project type."
  type: SupSoftwareProjectType!
  "The creation date."
  createdAt: DateTime
  "The last updated date."
  updatedAt: DateTime
  "The list of evaluation kit sources."
  compatibleEvalKits: [SupSoftwareProjectEvalKitSource!]
  "The evaluation kit source."
  compatibleEvalKit(id: ID!): SupSoftwareProjectEvalKitSource
}

"Payload associated with creating a software project."
type SupSoftwareProjectCreateSoftwareProjectPayload {
  "Software project identifier."
  id: ID
  errors: [SupSoftwareProjectCreateSoftwareProjectError!]
}

"Payload associated with deleting a software project."
type SupSoftwareProjectDeleteSoftwareProjectPayload {
  errors: [SupSoftwareProjectDeleteSoftwareProjectError!]
}

type SupSoftwareProjectEvalKitSource {
  sourceUrl: String!
  configXmlUrl: String!
  configUrl: String!
  readmeUrl: String!
  evalKitId: ID!
  evalKit: SupEvalKit!
}

type SupSoftwareProjectNotFoundError implements Error {
  message: String!
  errorCode: SupSoftwareProjectErrorCode!
}

type SupSoftwareProjectOperationFailedError implements Error {
  message: String!
  errorCode: SupSoftwareProjectErrorCode!
}

"Payload associated with updating a software project."
type SupSoftwareProjectUpdateSoftwareProjectPayload {
  errors: [SupSoftwareProjectUpdateSoftwareProjectError!]
}

union SupSoftwareProjectCreateSoftwareProjectError = SupSoftwareProjectOperationFailedError

union SupSoftwareProjectDeleteSoftwareProjectError = SupSoftwareProjectOperationFailedError | SupSoftwareProjectNotFoundError

union SupSoftwareProjectUpdateSoftwareProjectError = SupSoftwareProjectOperationFailedError | SupSoftwareProjectNotFoundError

"Input for software project creation."
input SupSoftwareProjectCreateSoftwareProjectInput {
  title: String!
  description: String
  type: SupSoftwareProjectType!
  compatibleEvalKits: [SupSoftwareProjectEvalKitSourceInput!]
}

"Input for software project delete."
input SupSoftwareProjectDeleteSoftwareProjectInput {
  "The software project identifier."
  id: ID!
}

input SupSoftwareProjectEvalKitSourceInput {
  sourceUrl: String!
  configXmlUrl: String!
  configUrl: String!
  readmeUrl: String!
  evalKitId: ID!
}

input SupSoftwareProjectFilterInput {
  types: [SupSoftwareProjectType!]
}

"Input for software project update."
input SupSoftwareProjectUpdateSoftwareProjectInput {
  id: ID!
  title: String
  description: String
  type: SupSoftwareProjectType
  "Replace the current software project evaluation kit sources with these ones."
  newCompatibleEvalKits: [SupSoftwareProjectEvalKitSourceInput!]!
}

enum SupSoftwareProjectErrorCode {
  OPERATION_FAILED
  SUP_SOFTWARE_PROJECT_NOT_FOUND
}

enum SupSoftwareProjectType {
  APPLICATION
  EXAMPLE
}

type SupSolutionTemplate {
  "The solution template identifier."
  id: ID!
  "The solution template title."
  title: String!
  "The detailed description."
  description: String
  "The solution source url."
  solutionSourceUrl: String
  "The creation date."
  createdAt: DateTime
  "The last updated date."
  updatedAt: DateTime
  "The list of part identifiers associated with the solution template."
  evalKitIds: [ID!]! @deprecated(reason: "Use 'compatibleEvalKits' instead")
  "The list of software projects identifiers associated with the solution template."
  softwareProjectIds: [ID!]!
  evalKits: [SupEvalKit!]!
  softwareProjects: [SupSoftwareProject!]!
  "The esd source."
  esdSource: SupSolutionTemplateESDSource!
  "The list of solution template images."
  previewImages: [SupImage!]
  "The list of solution template images."
  bestPreviewImage: SupImage
  "The list of application identifiers associated with the solution template."
  applicationIds: [String!]!
  "The list of parameter bundles associated with the solution template."
  parameters: [SupSolutionTemplateParameterBundle!]!
  "The list of evaluation kit parameter bundles associated with the solution template."
  compatibleEvalKits: [SupSolutionTemplateCompatibleEvalKit!]!
  "The list of AI model identifiers associated with the solution template."
  aiModelIds: [String!]
  applications: [SupCategory!]
}

type SupSolutionTemplateApplication {
  "The solution template application identifier."
  id: ID!
  "The solution template application description."
  description: String
  "The solution template application identifier."
  applicationId: String!
  "The list of parameter bundles associated with the solution template."
  parameters: [SupSolutionTemplateApplicationParameterBundle!]!
  application: [SupCategory!]
}

type SupSolutionTemplateApplicationIsExistedError implements Error {
  message: String!
  errorCode: SupSolutionTemplateErrorCode!
}

type SupSolutionTemplateApplicationNotFoundError implements Error {
  message: String!
  errorCode: SupSolutionTemplateErrorCode!
}

type SupSolutionTemplateApplicationParameterBundle {
  question: String!
  order: Int!
  required: Boolean!
  parameter: SupSolutionTemplateParameter!
  values: [SupSolutionTemplateParameterValue!]!
}

type SupSolutionTemplateCompatibleEvalKit {
  evalKitId: ID!
  evalKit: SupEvalKit!
  "The list of parameters."
  parameters: [SupSolutionTemplateParameterBundle!]!
}

"Payload associated with creating a solution template application."
type SupSolutionTemplateCreateSolutionTemplateApplicationPayload {
  "Solution template application identifier."
  id: ID
  errors: [SupSolutionTemplateCreateSolutionTemplateApplicationError!]
}

"Payload associated with creating a solution template."
type SupSolutionTemplateCreateSolutionTemplatePayload {
  "Solution template identifier."
  id: ID
  errors: [SupSolutionTemplateCreateSolutionTemplateError!]
}

"Payload associated with deleting a solution template application."
type SupSolutionTemplateDeleteSolutionTemplateApplicationPayload {
  errors: [SupSolutionTemplateDeleteSolutionTemplateApplicationError!]
}

"Payload associated with deleting a solution template."
type SupSolutionTemplateDeleteSolutionTemplatePayload {
  errors: [SupSolutionTemplateDeleteSolutionTemplateError!]
}

type SupSolutionTemplateESDSource {
  documentFileUrl: String
  compileModelUrl: String
}

type SupSolutionTemplateNotFoundError implements Error {
  message: String!
  errorCode: SupSolutionTemplateErrorCode!
}

type SupSolutionTemplateOperationFailedError implements Error {
  message: String!
  errorCode: SupSolutionTemplateErrorCode!
}

type SupSolutionTemplateParameter {
  title: String!
  info: SupSolutionTemplateParameterInfo
}

type SupSolutionTemplateParameterBundle {
  parameter: SupSolutionTemplateParameter!
  values: [SupSolutionTemplateParameterValue!]!
}

type SupSolutionTemplateParameterInfo {
  description: String
  imageUrl: String
  summary: String
}

type SupSolutionTemplateParameterValue {
  value: String!
  name: String!
  info: SupSolutionTemplateParameterInfo
}

"Payload associated with updating a solution template application."
type SupSolutionTemplateUpdateSolutionTemplateApplicationPayload {
  errors: [SupSolutionTemplateUpdateSolutionTemplateApplicationError!]
}

"Payload associated with updating a solution template."
type SupSolutionTemplateUpdateSolutionTemplatePayload {
  errors: [SupSolutionTemplateUpdateSolutionTemplateError!]
}

union SupSolutionTemplateCreateSolutionTemplateApplicationError = SupSolutionTemplateOperationFailedError | SupSolutionTemplateApplicationIsExistedError

union SupSolutionTemplateCreateSolutionTemplateError = SupSolutionTemplateOperationFailedError

union SupSolutionTemplateDeleteSolutionTemplateApplicationError = SupSolutionTemplateOperationFailedError | SupSolutionTemplateApplicationNotFoundError

union SupSolutionTemplateDeleteSolutionTemplateError = SupSolutionTemplateOperationFailedError | SupSolutionTemplateNotFoundError

union SupSolutionTemplateUpdateSolutionTemplateApplicationError = SupSolutionTemplateOperationFailedError | SupSolutionTemplateApplicationNotFoundError

union SupSolutionTemplateUpdateSolutionTemplateError = SupSolutionTemplateOperationFailedError | SupSolutionTemplateNotFoundError

input SupSolutionTemplateApplicationCreateParameterBundleInput {
  order: Int!
  required: Boolean!
  parameter: SupSolutionTemplateCreateParameterInput!
  values: [SupSolutionTemplateCreateParameterValueInput!]!
  question: String!
}

input SupSolutionTemplateApplicationRemoveParameterBundleInput {
  parameterTitle: String!
}

input SupSolutionTemplateApplicationUpdateParameterBundleInput {
  order: Int
  required: Boolean
  "The parameter identifier by parameter's title."
  parameter: SupSolutionTemplateUpdateParameterInput!
  "Replace the parameter values with these ones."
  newValues: [SupSolutionTemplateCreateParameterValueInput!]
  question: String!
}

input SupSolutionTemplateCompatibleEvalKitInput {
  "The evaluation kit identifier. Can be duplicated."
  evalKitId: ID!
  parameters: [SupSolutionTemplateParameterBundleInput!]
}

input SupSolutionTemplateCreateParameterInfoInput {
  description: String!
  imageUrl: String
  summary: String
}

input SupSolutionTemplateCreateParameterInput {
  info: SupSolutionTemplateCreateParameterInfoInput
  title: String!
}

input SupSolutionTemplateCreateParameterValueInput {
  info: SupSolutionTemplateCreateParameterInfoInput
  value: String!
  name: String!
}

input SupSolutionTemplateCreateSolutionTemplateApplicationInput {
  "The solution template application indentifier."
  applicationId: String!
  "The solution template application description."
  description: String
  "The list of application parameters associated with the solution template application."
  parameters: [SupSolutionTemplateApplicationCreateParameterBundleInput!]!
}

"Input for solution template creation."
input SupSolutionTemplateCreateSolutionTemplateInput {
  "The solution template title."
  title: String!
  "The solution template description."
  description: String
  "The ESD source."
  esdSource: SupSolutionTemplateEsdSourceInput!
  "The list of application identifiers associated with the solution template."
  applicationIds: [String!]
  "The list of software project identifiers associated with the solution template."
  softwareProjectIds: [ID!]
  "The list of solution template images input. The first image will be the best preview image."
  previewImages: [SupSolutionTemplateFileInput!]!
  "The list of parameters associated with the solution template application."
  parameters: [SupSolutionTemplateParameterBundleInput!]
  "The list of evaluation kit associated with the solution template."
  compatibleEvalKits: [SupSolutionTemplateCompatibleEvalKitInput!]
}

"Input for solution template application delete."
input SupSolutionTemplateDeleteSolutionTemplateApplicationInput {
  "The solution template application identifier."
  id: ID!
}

"Input for solution template delete."
input SupSolutionTemplateDeleteSolutionTemplateInput {
  "The solution template identifier."
  id: ID!
}

input SupSolutionTemplateEsdSourceInput {
  "The ESD document file."
  documentFile: SupSolutionTemplateFileInput!
  "The ESD compile model file."
  compileModel: SupSolutionTemplateFileInput
}

input SupSolutionTemplateFileInput {
  fileId: String!
  fileType: String!
  fileName: String!
}

input SupSolutionTemplateParameterBundleInput {
  parameter: SupSolutionTemplateParameterInput!
  values: [SupSolutionTemplateParameterValueInput!]!
}

input SupSolutionTemplateParameterInput {
  title: String!
}

input SupSolutionTemplateParameterValueInput {
  name: String!
  value: String!
}

input SupSolutionTemplateUpdateParameterInfoInput {
  description: String!
  imageUrl: String
  summary: String
}

input SupSolutionTemplateUpdateParameterInput {
  info: SupSolutionTemplateUpdateParameterInfoInput
  title: String!
}

input SupSolutionTemplateUpdateSolutionTemplateApplicationInput {
  "The solution template application GRID indentifier."
  id: ID!
  "The solution template application description."
  description: String
  "The update list of application parameters associated with the solution template application."
  updateParameters: [SupSolutionTemplateApplicationUpdateParameterBundleInput!]
  "The add list of application parameters associated with the solution template application."
  addParameters: [SupSolutionTemplateApplicationCreateParameterBundleInput!]
  "The remove list of application parameters associated with the solution template application."
  removeParameters: [SupSolutionTemplateApplicationRemoveParameterBundleInput!]
}

"Input for solution template update."
input SupSolutionTemplateUpdateSolutionTemplateInput {
  id: ID!
  "The ESD source."
  newEsdSource: SupSolutionTemplateEsdSourceInput
  "The solution template title."
  title: String!
  "The solution template description."
  description: String
  "Remove list of application identifiers associated with the solution template."
  removeApplicationIds: [String!]
  "Remove list of application identifiers associated with the solution template."
  addApplicationIds: [String!]
  "Add list of software project identifiers associated with the solution template."
  addSoftwareProjectIds: [ID!]
  "Remove list of software project identifiers associated with the solution template."
  removeSoftwareProjectIds: [ID!]
  "Replace the current solution template preview images with these ones. The first image will be used as a best preview image."
  newPreviewImages: [SupSolutionTemplateFileInput!]
  "Replace the current solution template parameters with these ones."
  newParameters: [SupSolutionTemplateParameterBundleInput!]
  "Replace the current solution template compatible eval kits with these ones."
  newCompatibleEvalKits: [SupSolutionTemplateCompatibleEvalKitInput!]
}

enum SupSolutionTemplateErrorCode {
  OPERATION_FAILED
  SUP_SOLUTION_TEMPLATE_NOT_FOUND
  SUP_SOLUTION_TEMPLATE_APPLICATION_IS_EXISTED
  SUP_SOLUTION_TEMPLATE_APPLICATION_NOT_FOUND
}

interface ManOrderEvent {
  id: ID!
  order: ManOrder!
  eventType: ManOrderEventType!
  timestamp: Int!
}

type ManAABB {
  topLeft: ManPoint2D
  bottomRight: ManPoint2D
  area: ManArea
}

type ManAngle {
  native: Int
  radians: Float
  degrees: Float
}

type ManArea {
  native: Int
  mm2: Float
  mil2: Float
  inSq: Float
}

type ManAssembly {
  id: ID
  boardMeta: ManBoardMeta
  projectId: ID
  commitId: ID
  variant: String
  bomSelection: ID
  package: ManPackageJob
}

type ManBoardDetails {
  path: [ManPathSegment]
  polygon(quant: Int!): [ManPoint2D]
  aabb: ManAABB
}

type ManBoardMeta {
  id: ID
  projectId: String
  boardDetails: ManBoardDetails
  parts: [ManPart]
  consignmentCount: Int!
  bomIssues: ManBomIssues!
  placementStats: ManPlacementInfo
  minClearance: ManLength
  minAnnularRing: ManLength
  stackUp: [ManLayer]
}

type ManBomIssues {
  issueCount: Int!
  warningCount: Int!
}

type ManBomResolution {
  parts: [ManPart!]!
}

type ManConsignmentDocs {
  pdf: String!
  html: String!
}

type ManCreateAssemblyResponse {
  assembly: ManAssembly
}

type ManCreateOrderResponse {
  order: ManOrder
}

type ManFeatures {
  availablePaymentOptions: [ManPaymentMethod!]!
}

type ManLayer {
  type: ManLayerType
  thickness: ManLength
  copperWeight: Float
  overlayColour: ManSilkScreenColour
  maskColour: ManSolderMaskColour
  process: String
  material: String
}

type ManLength {
  mm: Float
  mil: Float
  inch: Float
  "native units of 1\/10000 of a mil"
  native: Int
}

type ManOffer {
  price: ManPrice
  minQty: Int
}

type ManOrder {
  id: ID
  reference: String
  createdBy: ManUser
  createdAt: DateTime
  shipDate: DateTime
  boardName: String
  boardPreview: String
  stripeSecret: ID
  checkoutURL: String
  rapidQuote: ManQuoteInfo
  assembly: ManAssembly
  shipping: ManShippingDetails
  status: ManOrderStatus
  events: [ManOrderEvent]
}

type ManOrderAcceptedEvent implements ManOrderEvent {
  id: ID!
  order: ManOrder!
  eventType: ManOrderEventType!
  timestamp: Int!
  paymentSelection: ManPaymentSelection!
}

type ManOrderBatchedEvent implements ManOrderEvent {
  id: ID!
  order: ManOrder!
  eventType: ManOrderEventType!
  timestamp: Int!
}

type ManOrderCancelEvent implements ManOrderEvent {
  id: ID!
  order: ManOrder!
  eventType: ManOrderEventType!
  timestamp: Int!
}

type ManOrderConsignmentDetailsEvent implements ManOrderEvent {
  id: ID!
  order: ManOrder!
  eventType: ManOrderEventType!
  timestamp: Int!
  shipping: ManShippingDetails!
  receiveBy: DateTime!
  consignmentId: ID!
  documents: ManConsignmentDocs!
  parts: [ManPartQuantity!]!
}

type ManOrderCreatedEvent implements ManOrderEvent {
  id: ID!
  order: ManOrder!
  eventType: ManOrderEventType!
  timestamp: Int!
}

type ManOrderEmsAcceptedEvent implements ManOrderEvent {
  id: ID!
  order: ManOrder!
  eventType: ManOrderEventType!
  timestamp: Int!
}

type ManOrderInvoicedEvent implements ManOrderEvent {
  id: ID!
  order: ManOrder!
  eventType: ManOrderEventType!
  timestamp: Int!
  invoiceId: String!
  poReference: String!
}

type ManOrderPaidEvent implements ManOrderEvent {
  id: ID!
  order: ManOrder!
  eventType: ManOrderEventType!
  timestamp: Int!
}

type ManOrderPartsOrderedEvent implements ManOrderEvent {
  id: ID!
  order: ManOrder!
  eventType: ManOrderEventType!
  timestamp: Int!
}

type ManOrderPartsReceivedEvent implements ManOrderEvent {
  id: ID!
  order: ManOrder!
  eventType: ManOrderEventType!
  timestamp: Int!
}

type ManOrderPcbsOrderedEvent implements ManOrderEvent {
  id: ID!
  order: ManOrder!
  eventType: ManOrderEventType!
  timestamp: Int!
}

type ManOrderPcbsReceivedEvent implements ManOrderEvent {
  id: ID!
  order: ManOrder!
  eventType: ManOrderEventType!
  timestamp: Int!
}

type ManOrderProcessStartEvent implements ManOrderEvent {
  id: ID!
  order: ManOrder!
  eventType: ManOrderEventType!
  timestamp: Int!
}

type ManOrderReceivedEvent implements ManOrderEvent {
  id: ID!
  order: ManOrder!
  eventType: ManOrderEventType!
  timestamp: Int!
}

type ManOrderReviewedEvent implements ManOrderEvent {
  id: ID!
  order: ManOrder!
  eventType: ManOrderEventType!
  timestamp: Int!
}

type ManOrderShipEstimateEvent implements ManOrderEvent {
  id: ID!
  order: ManOrder!
  eventType: ManOrderEventType!
  timestamp: Int!
}

type ManOrderShippedEvent implements ManOrderEvent {
  id: ID!
  order: ManOrder!
  eventType: ManOrderEventType!
  timestamp: Int!
  trackingNumber: String!
  carrier: ManShippingCarrier!
  trackingLink: String!
}

type ManPackageJob {
  id: ID
  status: String
  errors: [String]
}

type ManPart {
  id: ID
  pinCount: Int
  type: ManMountingType
  partChoices: [ManPartChoice]
  selectedChoice: ManPartChoice
  name: String
  comment: String
  description: String
  sourcing: ManSourcing!
  placements: [ManPlacement]
  placementCount: Int
  issues: [ManPartIssue!]!
  status: ManPartStatus
}

type ManPartChoice {
  mpn: String
  manufacturer: String
  suppliers: [ManPurchaseOption]
  description: String
  lifecycle: String
  octopartId: String
  image: String
  octopartUrl: String
}

type ManPartQuantity {
  reference: String!
  quantity: Int!
  linkedPart: ManPartChoice
  placements: [ManPlacement!]!
}

type ManPathSegment {
  type: ManPathType
  vertex: ManPoint2D
  startAngle: ManAngle
  endAngle: ManAngle
  radius: ManLength
}

type ManPaymentSelection {
  method: ManPaymentMethod!
  purchaseOrderReference: String
}

type ManPlacement {
  refdes: String
  location: ManPoint2D
  side: ManSide
  size: ManPoint2D
  aabb: ManAABB
}

type ManPlacementInfo {
  bomLines: Int
  totalPlacements: Int
  thPlacements: Int
  smtPlacements: Int
  topPlacements: Int
  botPlacements: Int
  dualSided: Boolean
}

type ManPoint2D {
  x: ManLength
  y: ManLength
}

type ManPrice {
  amount: Decimal
  currency: ManCurrency
}

type ManPurchaseOption {
  supplier: String
  inventory: Int
  sku: String
  offers: [ManOffer]
}

type ManQuote {
  id: ID!
  type: String
  items: [ManQuoteItem]
  leadtime: Int
  total: Decimal
  violations: [ManViolation]
  valid: Boolean
}

type ManQuoteInfo {
  selectedQuote: ManQuote
  quoteRequest: ManRapidQuoteRequest
  response: ManRapidQuoteResponse
}

type ManQuoteItem {
  category: ManQuoteCategory
  amount: Decimal
  ident: String
}

type ManRapidQuoteRequest {
  id: ID
  qty: Int
  meta: ManBoardMeta
  shipping: ManShippingDetails
  bomResolutionUrl: String
  requestorId: ID
}

type ManRapidQuoteResponse {
  id: ID
  request: ManRapidQuoteRequest
  quotes(wait: Int = 5): [ManQuote]
}

type ManShippingDetails {
  name: String
  email: String
  phone: String
  line1: String
  line2: String
  country: String
  city: String
  state: String
  postal: String
  method: ManShippingMethod
}

type ManShippingMethod {
  carrier: String
  service: String
}

type ManUser {
  "The internal user ID."
  userId: String!
  "Null if the user no longer exists."
  userName: String
  "Null if the user no longer exists."
  email: String
  "Null if the user no longer exists."
  firstName: String
  "Null if the user no longer exists."
  lastName: String
}

type ManViolation {
  "dot delimited string describing location of issue \nlayers.[1].process  "
  field: String
  type: ManViolationType
  description: String
}

input ManAABBInput {
  topLeft: ManPoint2DInput
  bottomRight: ManPoint2DInput
}

input ManBoardMetaInput {
  projectId: String
  boardOutline: [ManPathSegmentInput]
  parts: [ManPartInput]
  minClearance: Int
  minAnnularRing: Int
  stackUp: [ManLayerInput]
}

input ManLayerInput {
  type: ManLayerType
  thickness: Int
  copperWeight: Float
  overlayColour: ManSilkScreenColour
  maskColour: ManSolderMaskColour
  process: String
  material: String
}

input ManOfferInput {
  price: ManPriceInput
  minQty: Int
}

input ManOrderBatchedInput {
  orderId: ID!
}

input ManOrderConsignmentDetailsInput {
  orderId: ID!
  shipping: ManShippingDetailsInput!
  receiveBy: DateTime!
  consignmentId: ID!
  partQuantities: [ManPartQuantityInput!]!
}

input ManOrderEmsAcceptInput {
  orderId: ID!
  emsReference: String
}

input ManOrderPartsOrderedInput {
  orderId: ID!
}

input ManOrderPartsReceivedInput {
  orderId: ID!
}

input ManOrderPcbsOrderedInput {
  orderId: ID!
}

input ManOrderPcbsReceivedInput {
  orderId: ID!
}

input ManOrderProcessStartInput {
  orderId: ID!
}

input ManOrderReviewInput {
  orderId: ID!
}

input ManOrderShipEstimateInput {
  orderId: ID!
  estimateDate: DateTime!
}

input ManOrderShippedInput {
  orderId: ID!
  trackingNumber: String
  carrier: ManShippingCarrier
}

input ManPartChoiceInput {
  mpn: String
  manufacturer: String
  octopartId: String
  suppliers: [ManPurchaseOptionInput]
}

input ManPartInput {
  id: ID
  componentId: ID
  type: ManMountingType
  pinCount: Int
  partChoices: [ManPartChoiceInput]
  placements: [ManPlacementInput]
}

input ManPartQuantityInput {
  id: ID!
  amount: Int!
}

input ManPartSelectionInput {
  part: ID!
  selection: ID!
  sourcing: ManSourcing!
}

input ManPathSegmentInput {
  type: ManPathType
  "Either center of a circle for the arc, or the vertex location"
  vertex: ManPoint2DInput
  "start point of arc in billionth of a rotation (range from 0 to 999999999)"
  startAngle: Int
  "end point of arc in billionth of a rotation (range from 0 to 999999999)"
  endAngle: Int
  "radius of the circle if an arc"
  radius: Int
}

input ManPaymentSelectionInput {
  method: ManPaymentMethod!
  purchaseOrderReference: String
}

input ManPlacementInput {
  "schematic refdes"
  refdes: String
  "Location of the part"
  location: ManPoint2DInput
  "Side of the board"
  side: ManSide
  "aabb of the part"
  aabb: ManAABBInput
}

input ManPoint2DInput {
  x: Int!
  y: Int!
}

input ManPriceInput {
  amount: Decimal
}

input ManProjectFeatureInput {
  projectId: ID!
}

input ManPurchaseOptionInput {
  supplier: String
  inventory: Int
  offers: [ManOfferInput]
}

input ManQuoteInput {
  id: ID!
  type: String
  "the quote line items"
  items: [ManQuoteInputItem]
  "leadtime in business days"
  leadtime: Int
  "any parameter violation which invalidate the quote"
  violations: [ManViolationInput]
}

input ManQuoteInputItem {
  category: ManQuoteCategory
  amount: Decimal
  ident: String
}

input ManShippingDetailsInput {
  name: String
  email: String
  phone: String
  line1: String
  line2: String
  country: String
  city: String
  state: String
  postal: String
  method: ManShippingMethodInput
}

input ManShippingMethodInput {
  carrier: String
  service: String
}

input ManViolationInput {
  "dot delimited string describing location of issue \nlayers.[1].process  "
  field: String
  type: ManViolationType
  description: String
}

enum ManAccess {
  ALLOW_MPN
  IS_EMS
  IS_CREATOR
}

enum ManCurrency {
  USD
}

enum ManLayerType {
  COVERLAY
  SURFACE_FINISH
  SIGNAL
  PLANE
  CORE
  PRE_PREG
  SOLDER_MASK
  OVERLAY
}

enum ManMountingType {
  THROUGH_HOLE
  SURFACE_MOUNT
}

enum ManOrderEventType {
  CREATED
  ACCEPTED
  EMS_ACCEPTED
  PAID
  INVOICED
  CONSIGNMENT_DETAILS
  TIME_ESTIMATION
  REVIEWED
  BATCHED
  PARTS_ORDERED
  PCBS_ORDERED
  PARTS_RECEIVED
  PCBS_RECEIVED
  PROCESS_START
  SHIPPED
  RECEIVED
  CANCEL
}

enum ManOrderStatus {
  QUOTING
  PAYMENT_PROCESSING
  PLACED
  PROCESSING
  MANUFACTURING
  SHIPPING
  CANCELLED
  COMPLETE
}

enum ManPartIssue {
  BAD_LIFECYCLE
  NO_SELECTION
  UNAVAILABLE
  NOT_FOUND
  INSUFFICIENT_STOCK
  STOCK_LOW
}

enum ManPartStatus {
  GOOD
  WARN
  ISSUE
}

enum ManPathType {
  ARC
  VERTEX
}

enum ManPaymentMethod {
  CREDIT_CARD
  DIRECT_APPROVAL
}

enum ManQuoteCategory {
  FABRICATION
  ASSEMBLY
  BOM
  SHIPPING
  NRE
}

enum ManShippingCarrier {
  USPS
  UPS
}

enum ManSide {
  TOP
  BOTTOM
}

enum ManSilkScreenColour {
  YELLOW
  RED
  GREEN
  BLUE
  BLACK
  WHITE
}

enum ManSolderMaskColour {
  BLUE
  RED
  GREEN
  LIGHT_GREEN
  MATTE_GREEN
  YELLOW
  BLACK
  MATTE_BLACK
  WHITE
  DARK_BROWN
  TRANSPARENT
}

enum ManSourcing {
  ALTIMADE
  CONSIGN
  DNP
}

enum ManViolationType {
  INCONSISTENT
  TOO_BIG
  TOO_SMALL
  UNKNOWN
  UNSUPPORTED
}

"An application belonging to an organization which facilitates access. Users interact with the Nexar API through applications."
type AdmApplication {
  "The scopes assigned to this application."
  scopes: [AdmApplicationScope!]!
  "Information about supply quota if this application has the supply scope."
  supplyCounts: AdmSupplyCounts
  "Security detail for this application, such as its client id and secret."
  security: AdmApplicationSecurity!
  "The organization to which this application belongs."
  organizationId: String
  "The name of this application."
  name: String!
  "The description of this application."
  description: String
  "Whether or not this application has been deleted."
  deleted: Boolean!
  "When this application was created."
  createdDate: DateTime!
  "A unique identifier for the application."
  id: String!
}

"A scope for an application, e.g. design, supply or manufacturing."
type AdmApplicationScope {
  "The application to which this scope applies."
  applicationId: String!
  "The scope to which the application has been granted access."
  scope: String!
}

"Security access details for an application."
type AdmApplicationSecurity {
  "The application to which this scope applies."
  applicationId: String!
  "The unique client id for this application."
  clientId: String!
  "The unique client secret for this application. Guard this secret carefully!"
  clientSecret: String!
}

"An `AdmEvtCustomEvent` is an entity representing a message generaged from the API."
type AdmEvtCustomEvent {
  "The unique Identifier for this message."
  id: String!
  "Identifier of the application which generated the event (null if system generated)."
  senderApplicationId: String
  "Identifier of the application to receive the event."
  destinationApplicationId: String!
  "Identifier of object which the event was generated for (project, workspace, part, etc)."
  subject: String
  "Unique global identifier of the user generating the event (null if client credentials are used)."
  userId: String
  "Time of event creation."
  createdAt: DateTime!
  type: AdmEventType!
  "`customData` is extra user specified data attached to the a Custom Event."
  customData: String
}

"An `AdmEvtSendAppNotificationPayload` is the return value for the `admEvtSendAppNotification` mutation."
type AdmEvtSendAppNotificationPayload {
  "`event` is the underlying sent event if available."
  event: AdmEvtCustomEvent
  "`errors` found during execution."
  errors: [AdmRequestError!]
}

"An Organization is an entity representing a partner, company or individual engaging with Nexar."
type AdmOrganization {
  "The users belonging to this organization."
  users: [AdmUser!]!
  "Invitations sent for others to join this organization."
  invitations: [AdmUserInvitation!]!
  "The applications belonging to this organization through which users interact with the API."
  applications: [AdmApplication!]!
  "Whether this is the current user's default organization."
  isDefault: Boolean!
  "The name of this organization."
  name: String!
  "When this organization was created."
  createdDate: DateTime!
  "A unique identifier for the organization."
  id: String!
}

type AdmRequestError {
  message: String!
  code: String!
}

"Supply count information for supply applications."
type AdmSupplyCounts {
  "The count of supply parts used this month."
  partCounter: Int!
  "The monthly quota of parts which can be returned through supply API queries."
  partLimit: Int!
}

"A user represents and individual who can login to Nexar and interact with API through applications of this organization."
type AdmUser {
  "The email address for the user used as their username."
  userName: String!
  "The user's first name."
  firstName: String!
  "The user's last name."
  lastName: String!
  "When the user was created in the system."
  createdDate: DateTime!
  "A unique identifier for the user."
  id: String!
}

"An invitation sent for a user to join an invitation."
type AdmUserInvitation {
  "The organization to which the user has been invited."
  organizationId: String
  "The email of the user receiving the invitation to join the organization."
  email: String
  "Whether or not the user accepted the invitation to join the organization."
  accepted: Boolean!
}

"An `AdmEvtSendAppNotificationInput` the input object for the `admEvtSendAppNotification` mutation."
input AdmEvtSendAppNotificationInput {
  "Identifier of application to send notification event."
  destinationApplicationId: String!
  "Identifier of object the event is generate for (project, workspace, part, etc)."
  subject: String
  "customData is destination application specified extra data."
  customData: Any
}

enum AdmEventType {
  API_CUSTOM_EVENT
}

"A generic `dat` domain error."
interface DatError {
  "A short description of the error."
  message: String!
}

type DatBomAnalysis {
  items: [DatBomPartItem!]!
  level: DatBomAnalysisLevel!
  message: String!
}

type DatBomCategory {
  categoryID: Int!
}

type DatBomPart {
  partId: String!
  confidence: Float!
  strategy: DatBomPartSearchStrategy!
  "Nexar supply part data for internal use only. Array of size 1."
  part: [SupPart]!
}

type DatBomPartHistory {
  threeMonthGrowthPercentage: Float!
}

type DatBomPartItem {
  itemRefId: String
  partId: String!
  alternateCandidatePartIds: [String!]
  quantity: Int!
}

type DatBomPartsResult {
  itemRefId: String
  parts: [DatBomPart!]!
}

type DatEddiCategory {
  id: Int!
  name: String!
}

type DatEddiEdition {
  eddiTimeSeries(where: DatEddiTimeSeriesFilterInput): [DatEddiTimeSeries!]!
  id: Int!
  title: String!
  releaseDate: DateTime!
}

type DatEddiIndex {
  indexDate: DateTime!
  supplyIndex: Float
  demandIndex: Float
}

type DatEddiTimeSeries {
  children(where: DatEddiTimeSeriesFilterInput): [DatEddiTimeSeries!]
  indices(where: DatEddiIndexFilterInput): [DatEddiIndex!]!
  category: DatEddiCategory
}

"Error indicating that the SCR processing run could not be deleted."
type DatScrCouldNotDeleteJobError implements DatError {
  message: String!
  "Job to be deleted."
  job: DatScrJob!
}

type DatScrCreateJobPayload {
  datScrJob: DatScrJob
  errors: [DatScrCreateJobError!]
}

type DatScrDeleteJobPayload {
  datScrJob: DatScrJob
  errors: [DatScrDeleteJobError!]
}

"Grouped SCR part information."
type DatScrIpnPartInfo {
  "Number between 0 and 1 indicating what proportion of the past 365 days the globally available stock for all parts in the group combined was at or above the input EAU value."
  ipnHistoricalProcurability: Float!
  "Weekly averages of the sum over the list of input parts of the total global stock available at franchised distributors for the last 51 full calendar weeks."
  weeklyMarketAvailability("Returns the first N elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last N elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String): DatScrPartAvailabilitySnapshotConnection
  "Part IDs in this group."
  partIds: [String!]!
  "Expected Annual Usage."
  eau: Long!
}

"Contains information about an SCR processing job."
type DatScrJob {
  "The ID of the user who owns the job."
  userId: String!
  "The ID of this job."
  jobId: String!
  "An optional label to easily identify the job."
  label: String
  "The date and time of when the job was requested."
  uploadDatetime: DateTime!
  "The current state of the job."
  jobState: DatScrJobState!
  "A small message relating to running of the job."
  jobMessage: String
  "Statistics relating to the running of this job."
  runStats: DatScrRunStats
}

type DatScrModelInfo {
  "Number of days into the future that the SCR predictions are run for (estimatedDaysOfSupply and probableAvailabilityWindow)."
  predictionHorizonDays: Int!
}

type DatScrPartAvailabilitySnapshot {
  snapshotStartDate: DateTime!
  availability: Int!
}

"A connection to a list of items."
type DatScrPartAvailabilitySnapshotConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [DatScrPartAvailabilitySnapshotEdge!]
  "A flattened list of the nodes."
  nodes: [DatScrPartAvailabilitySnapshot!]
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type DatScrPartAvailabilitySnapshotEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DatScrPartAvailabilitySnapshot!
}

"SCR part information."
type DatScrPartInfo {
  "Number between 0 and 1 that indicates what proportion of the last 365 days that a parts globally available stock was at or above the input EAU value."
  historicalProcurability: Float
  "Weekly average of the total global stock available at franchised distributors over the past week."
  marketAvailabilityToday: Int @deprecated(reason: "Use the `weeklyMarketAvailability` field instead.")
  "Weekly average of the total global stock available at franchised distributors for last week."
  marketAvailability7dAgo: Int @deprecated(reason: "Use the `weeklyMarketAvailability` field instead.")
  "Weekly average of the total global stock available at franchised distributors for two weeks ago."
  marketAvailability14dAgo: Int @deprecated(reason: "Use the `weeklyMarketAvailability` field instead.")
  "Weekly average of the total global stock available at franchised distributors for three weeks ago."
  marketAvailability21dAgo: Int @deprecated(reason: "Use the `weeklyMarketAvailability` field instead.")
  "Weekly average of the total global stock available at franchised distributors for four weeks ago."
  marketAvailability28dAgo: Int @deprecated(reason: "Use the `weeklyMarketAvailability` field instead.")
  "Monthly averages of the total global stock available at franchised distributors for the last 11 full calendar months."
  monthlyMarketAvailability: [DatScrPartAvailabilitySnapshot!]
  "Weekly averages of the total global stock available at franchised distributors for the last 51 full calendar weeks."
  weeklyMarketAvailability("Returns the first N elements from the list." first: Int "Returns the elements in the list that come after the specified cursor." after: String "Returns the last N elements from the list." last: Int "Returns the elements in the list that come before the specified cursor." before: String): DatScrPartAvailabilitySnapshotConnection
  "Estimated number of days into the future that the total global stock for a part is predicted to remain above the EAU value, assuming the part is not restocked."
  estimatedDaysOfSupply: Int
  "Estimated number of days into the future that the total global stock for a part is predicted to remain above the EAU value, including predicted restock events."
  probableAvailabilityWindow: Float
  "Risk rating for the procurability of this part."
  rating: DatScrPartInfoRating
  "Input Part ID, as returned from an Octopart supply data query."
  partId: String!
  "Input Estimated Annual Usage (EAU) as a number of pieces."
  eau: Int!
}

"Error indicates that the user has exceeded their quota."
type DatScrQuotaExceededError implements DatError {
  message: String!
  "The number of distinct parts resolved for the user in the current period."
  usage: Int!
  "The number of allowed parts resolved for the current period."
  quota: Int!
}

"A supply-chain resilience report."
type DatScrReport {
  "The SCR job that created this report."
  jobId: String!
  "A URL to download this report."
  downloadUrl: String!
}

"Statistics relating to the running of a job. Procurability here is with respect to a given EAU (estimated annual usage)."
type DatScrRunStats {
  "Total number of parts requested for processing."
  numTotalParts: Int
  "Total number of parts resolved."
  numResolvedParts: Int
  "Number of parts with no historical procurability."
  numHpZeroParts: Int
  "Number of parts with a historical procurability between zero and one."
  numHpIntervalParts: Int
  "Number of parts with complete historical procurability."
  numHpOneParts: Int
  "Number of parts that are currently procurable."
  numProcCurrent: Int
  "Number of parts that were procurable seven days ago."
  numProc7dAgo: Int
  "Number of parts that were procurable 14 days ago."
  numProc14dAgo: Int
  "Number of parts that were procurable 21 days ago."
  numProc21dAgo: Int
  "Number of parts that were procurable 28 days ago."
  numProc28dAgo: Int
  "Number of parts that were not procurable last week that are now procurable."
  numRestocked: Int
  "Number of parts that were procurable last week that are now non-procurable."
  numDestocked: Int
}

"Error indicates that an SCR subscription could not be found."
type DatScrSubscriptionNotFoundError implements DatError {
  message: String!
}

"User's metered usage statistics."
type DatScrUsage {
  "Total number of distinct resolved parts within the current period."
  countDistinctParts: Int!
  "The start date of the current period."
  fromDate: String!
  "Allowed quota of the user within the current period."
  quota: Int!
}

type SupOctocartLink {
  sellerId: String!
  cartUrl: String
}

union DatScrCreateJobError = DatScrQuotaExceededError | DatScrSubscriptionNotFoundError

union DatScrDeleteJobError = DatScrCouldNotDeleteJobError

input DatBomItemInput {
  itemRefId: String
  manufacturerName: String
  mpn: String
  description: String
  designator: String
}

input DatBomPartItemInput {
  itemRefId: String
  partId: String!
  alternateCandidatePartIds: [String!]
  quantity: Int!
}

input DatEddiCategoryFilterInput {
  and: [DatEddiCategoryFilterInput!]
  or: [DatEddiCategoryFilterInput!]
  id: IntOperationFilterInput
  name: StringOperationFilterInput
}

input DatEddiEditionFilterInput {
  and: [DatEddiEditionFilterInput!]
  or: [DatEddiEditionFilterInput!]
  id: IntOperationFilterInput
  title: StringOperationFilterInput
  releaseDate: DateTimeOperationFilterInput
}

input DatEddiIndexFilterInput {
  and: [DatEddiIndexFilterInput!]
  or: [DatEddiIndexFilterInput!]
  indexDate: DateTimeOperationFilterInput
  supplyIndex: FloatOperationFilterInput
  demandIndex: FloatOperationFilterInput
}

input DatEddiTimeSeriesFilterInput {
  and: [DatEddiTimeSeriesFilterInput!]
  or: [DatEddiTimeSeriesFilterInput!]
  category: DatEddiCategoryFilterInput
}

"A mapping to rename column headers in the CSV to known fields"
input DatScrColumnMapInput {
  "Name of the CSV column that corresponds to an internal part number"
  pn: String
  "Name of the CSV column that corresponds to the manufacturer's part number"
  mpn: String
  "Name of the CSV column that corresponds to the name of the manufacturer"
  manufacturer: String
  "Name of the CSV column that corresponds to the estimated annual usage"
  eau: String
}

"Input data to create an SCR job."
input DatScrCreateJobInput {
  "The Nexar file ID which contains the data to process in CSV format."
  fileId: String!
  "A label to add to the job for easier reference."
  label: String
  "The name remapping of the CSV columns."
  columnMapping: DatScrColumnMapInput
}

"Input data to delete an SCR job."
input DatScrDeleteJobInput {
  "The ID of the job to delete."
  jobId: String!
}

"Input data for an SCR part information query."
input DatScrPartInfoInput {
  "Part ID, as returned from an Octopart supply data query."
  partId: String!
  "Estimated Annual Usage (EAU) as a number of pieces."
  eau: Int!
}

input FloatOperationFilterInput {
  eq: Float
  neq: Float
  in: [Float]
  nin: [Float]
  gt: Float
  ngt: Float
  gte: Float
  ngte: Float
  lt: Float
  nlt: Float
  lte: Float
  nlte: Float
}

input IntOperationFilterInput {
  eq: Int
  neq: Int
  in: [Int]
  nin: [Int]
  gt: Int
  ngt: Int
  gte: Int
  ngte: Int
  lt: Int
  nlt: Int
  lte: Int
  nlte: Int
}

input SupOctocartItemInput {
  partId: String!
  offerId: String!
  quantity: Int!
  ipn: String
}

input SupOctocartPartsBySellerInput {
  sellerId: String!
  items: [SupOctocartItemInput!]!
}

enum DatBomAnalysisLevel {
  ERROR
  WARNING
  SUGGESTION
}

enum DatBomPartSearchStrategy {
  EXACT
  EXACT_MPN_ONLY
  PARTIAL
  FUZZY
}

"Possible states of an SCR processing run."
enum DatScrJobState {
  "Job has completed successfully."
  COMPLETED
  "The job has failed to process the data."
  FAILED
  "The job is still processing the data."
  RUNNING
  "Job is in an unknown state."
  UNKNOWN
}

"Possible levels of an SCR part rating."
enum DatScrPartInfoRating {
  "This part has had a volatile supply or been mainly unavailable in the past 12 months or is predicted to be unavailable in your desired quantity in the next 2 months."
  RED
  "This part has had occasional procurement issues in the past 12 months or availability has trended down significantly in the last quarter."
  AMBER
  "This part has been procurable for the past 12 months and is predicted to be available in your desired quantity for 2+ months."
  GREEN
}

interface DatRepReport {
  id: String!
  fileType: String!
  fileSize: Int!
  createdDate: DateTime!
  title: String!
}

type DatRepDownloadableFile {
  report: DatRepReport!
  downloadUrl: String!
  urlExpiryDate: DateTime!
}

type DatRepOctopartReport implements DatRepReport {
  id: String!
  fileType: String!
  fileSize: Int!
  createdDate: DateTime!
  title: String!
  companyId: String!
}

type DatRepOctopartReportRequest {
  id: String!
  companyId: String!
  reportTypeId: String!
  createdDate: DateTime!
  numActiveReports: Int!
  numDeletedReports: Int!
}

type DatRepOctopartReportRequestError implements Error {
  message: String!
}

type DatRepOctopartReportType {
  id: String!
  name: String!
  reportFamily: String!
  description: String
  frequency: String
  exampleUrl: String
}

"A connection to a list of items."
type DatRepReportsConnection {
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "A list of edges."
  edges: [DatRepReportsEdge!]
  "A flattened list of the nodes."
  nodes: [DatRepReport!]
  "Identifies the total count of items in the connection."
  totalCount: Int!
}

"An edge in a connection."
type DatRepReportsEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: DatRepReport!
}

type DatRepRequestOctopartReportsPayload {
  datRepOctopartReportRequest: [DatRepOctopartReportRequest!]
  errors: [DatRepRequestOctopartReportsError!]
}

union DatRepRequestOctopartReportsError = DatRepOctopartReportRequestError

input DatRepRequestOctopartReportsInput {
  companyId: String!
  reportTypeIds: [String!]!
}

input IDatRepReportFilterInput {
  and: [IDatRepReportFilterInput!]
  or: [IDatRepReportFilterInput!]
  id: StringOperationFilterInput
  fileType: StringOperationFilterInput
  fileSize: IntOperationFilterInput
  createdDate: DateTimeOperationFilterInput
  title: StringOperationFilterInput
}

input IDatRepReportSortInput {
  id: SortEnumType
  fileType: SortEnumType
  fileSize: SortEnumType
  createdDate: SortEnumType
  title: SortEnumType
}

enum SortEnumType {
  ASC
  DESC
}

enum ApplyPolicy {
  BEFORE_RESOLVER
  AFTER_RESOLVER
  VALIDATION
}

"The `Long` scalar type represents non-fractional signed whole 64-bit numeric values. Long can represent values between -(2^63) and 2^63 - 1."
scalar Long

"The built-in `Decimal` scalar type."
scalar Decimal

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime

"The multiplier path scalar represents a valid GraphQL multiplier path string."
scalar MultiplierPath

"Delegates a resolver to a remote schema."
directive @delegate("The path to the field on the remote schema." path: String "The name of the schema to which this field shall be delegated to." schema: String!) on FIELD_DEFINITION

"Annotates the original name of a type."
directive @source("The original name of the annotated type." name: String! "The name of the schema to which this type belongs to." schema: String!) repeatable on OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | INTERFACE | UNION | ENUM | ENUM_VALUE | INPUT_OBJECT | INPUT_FIELD_DEFINITION

directive @Binding(constraint: String!) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @BlockAll(roles: [SupRole!]!) on FIELD_DEFINITION

directive @Expensive on FIELD_DEFINITION

directive @HasPlanTier(tier: SupPlanTier!) on FIELD_DEFINITION | ARGUMENT_DEFINITION

directive @NexarRequire(feature: SupNexarFeatureID!) on FIELD_DEFINITION

directive @RequireAny(roles: [SupRole!]!) on FIELD_DEFINITION | ARGUMENT_DEFINITION

directive @RequireAuth on FIELD_DEFINITION | ARGUMENT_DEFINITION